### Vim 离开和回来
#### 挂起和继续
将 Vim 挂起,进入 Shell 里，然后再用 "fg" 命令回到 Vim。

	Ctrl-Z		//切换入 Shell 命令行
	$ ls .	  //使用 ls 命令
	$ fg		//回到 Vim 编辑器

#### 执行 Shell 命令
在 Vim 内部执行单个 Shell 命令，用 `:!{command}`
 
	:!ls
	:!dir
	:!{program}			执行 {program}	:r !{program}		  执行 {program} 并读取其输出	:w !{program}		  执行 {program} 传送文本至其输入	:[range]!{program}	 经由 {program} 过滤文本	 
在 Vim 窗口作为其输入和输出端口,类似于 Ctrl-Z
	:shell	 进入非终端仿真器
	$ exit	 返回 Vim 编辑器
	
#### 记忆有关信息;viminfo

	信息文件 viminfo 设计用来储存状态信息:		命令行和模式搜索的历史记录 		寄存器内文本 		各种文件的标记		缓存器列表		全局变量
每次退出 Vim 都把信息存放在 viminfo 文件内,重新启动时，就读取这些信息文件。可通过  
**:set viminfo=string**  
例如 : `:set viminfo=’1000,f1,<500`   *保存寄存器f[0|1]；500行为上限；1000个文件保存标记(a-z)*

选项 | 解释
----|---
<{num} | 保存行数上限
'{num} | N 个文件可以保存标记 (a-z)
`f{[0\|1]}` | 是否存储全局标记 (A-Z 和 0-9),0表示不存储，1或者f不做规定，标记就被存储
:{num} | 保存命令行历史记录内的行数@{num} | 保存输入行历史记录内的行数/{num} | 保存搜索历史记录内的行数r | 可移介质,其上的文件不保存标记 (可用多次)! | 以大写字母开头并且不含有小写字母的全局变量h | 启动时关闭选项 ’hlsearch’ 高亮显示% | 缓冲区列表 (只有当不带参数启动 Vim 时才用来恢复) c 用编码 ’encoding’ 转换文本n | 用于 viminfo 文件的名称 (必须为最后一项选项)

##### 重返 Vim 中断处
其实就是上次编辑退出的位置 : `'0`  
显示标记列表 : `:marks` 

##### 重返某文件
如果想回到最近编辑过的文件，可查看最近编辑文件列表 :   

    :oldfiles    查看编辑文件历史
    :e #<{num}   想编辑列表中的第 num 个文件
    :split #<3   也可用窗口分割来显示
如果以上操作太麻烦，可以用如下 :  
   
    :browse oldfiles     显示编辑文件历史
    q                    点击 q 退出
    //此时会提示输入编辑文件编号.

##### Vim 间信息移动
两个同时运行的 Vim 间交换寄存器内容，重新加载 viminfo 文件。
在第一个 Vim 里执行 : 
    
    :wviminfo! /tmp/viminfo
而在第二个 Vim 里执行 : 
    
    :rviminfo! /tmp/viminfo
`:wviminfo` 用字符 `!` 来强制重写一个已存在文件。如果省略而文件却存在，那么这些信息就跟那个文件合并到一起。  
`:rviminfo` 的 `!` 字符意味着所有的信息都被采用，这可能会重写一些已存在信息。若不用 `!` 字符，则只有那些尚未设定的信息才会被采用。  
这些命令也可以用来储存信息为将来所用。你可以让一个目录专门存放信息文件,而每一个所包含的信息各有其特殊的目的。  

#### 会话
将上次编辑的相关信息保存。这包括诸如文件列表、窗口布局、全局 变量、选项、以及其它信息。(究竟什么信息被记住,则由选项 ’sessionoptions’ 控制,稍后叙述。)  
    
    :mksession vimbook.vim    创建一个会话文件    :source vimbook.vim       还原这个会话
    $ vim -S vimbook.vim      启动 Vim 并还原某个特别的会话
那个曾经打开的窗口就还原了,跟以前一样的位置和大小。映射和选项值也像以前一样。 究竟还原了什么取决于 ’sessionoptions’ 选项。

单词 | 保存和恢复
----|---blank | 空窗口buffers | 隐藏和卸载的缓冲区,不光是那些在窗口里的curdir | 当前目录folds | 手动建立的折叠、打开/关闭的折叠和局部折叠选项globals | 大写字母开头且包含至少一个小写字母的全局变量。只保存字符串和数值类型。 
help | 帮助窗口localoptions | 局部于窗口或缓冲区的选项和映射 (不是局部选项的全局值) 
options | 所有的选项和映射 (也包括局部选项的全局值)resize | Vim 窗口的大小: ’lines’ 和 ’columns’sesdir | 会话文件所在的目录会成为当前目录 (用于通过网络访问别的系统的项目)slash | 文件名里的反斜杠被替换成正斜杠tabpages | 所有标签页;如果不包含,只恢复当前标签页。这样你可以为 每个标签页分别保存一个会话unix | 使用 Unix 换行格式 (单个 `<NL>`),即使在 Windows 或 DOS 上也是如此winpos | 整个 Vim 窗口的位置 winsize 窗口大小
winsize | 窗口大小


####会话用法
你正编辑着项目 "secret" 的文件,而你必须切换到项目 "boring" 的 文件上:
        :wall        :mksession! ~/.vim/secret.vim        :source ~/.vim/boring.vim
####会话记录和信息文件在大多数情况下,你将需要利用会话记录而非全部信息文件内的信息。这么做可以让 你切换到另一个会话记录,但却保留着命令行历史记录。并得以在一个会话期内把文本抄 进寄存器,而于另一个会话期把它粘贴出来。例如: 
        :mksession! ~/.vim/secret.vim        :wviminfo! ~/.vim/secret.viminfo而再次把它还原:        
        :source ~/.vim/secret.vim        :rviminfo! ~/.vim/secret.viminfo

###视图视图的用处在于你要以某种特定的方式编辑一个文件。例如,你以 ’number’ 选项显 示了行号,并定义了若干折叠。  事实上,当你储存会话时,每个窗口的视图都储存了。   
视图有两种基本用法 : 

1. 让 Vim 为视图文件挑一个文件名。你可以在以后编辑同一文件时还原该视图。为当前窗口储存视图,用: 
        :mkview 1Vim 将自行决定视图的储存位置。当你以后编辑同一文件时,用这个命令恢复该视图: 
        :loadview 1
*你可以用这个方法为同一个文件储存视图达十个之多,一个没序号的,而九个则有序 号 1 至 9。*

2. 命名视图  
第二种视图基本用法是把视图储存在一个你选定的文件内。你可以在编辑另外一个文件时载入这个视图。Vim 将接着转而编辑该视图规定的文件。这样你就可以用这种方法迅速换个文件来编辑,其所有的选项设定就跟它们在存盘时一样。
    例如,要保存当前文件的视图:        :mkview ~/.vim/main.vim你可以用这个命令把它还原: 
        :source ~/.vim/main.vim
        
###模式行
当你编辑一个特定的文件,你也许为该文件设定了特定的选项。每次键入这些命令很无 聊。而在许多人共享一个文件时,利用会话和视图来编辑这个文件也无济于事。  解决这个困境的方法是给文件加一个模式行。那是一行文本,它把一些只适用于该文 件的选项设定告诉 Vim。  
例如 : 
        
        //把这一行插入该文件起首五行或结尾五行
        /* vim:set shiftwidth=4: */
选项 ’modelines’ 规定了要在文件起首和结尾几行之内检查那儿是否包含了模式行。        
        //要检查十行        :set modelines=10
        //撤销这个设定        :set nomodeline
模式行可以用这种格式:  
        any-text vim:set {option}={value} ... : any-text
        
          其中 "any-text" 表示你可以在 Vim 实际用到的部分之前和之后加任意文本。这就允许你使
        它看起来像个注释,正如上例采用了 /* 和 */。  
                  " vim: " 部分使 Vim 识别出这个模式行。在 "vim" 的前面必须有空格,除非 "vim"置于行首。          因此像 "gvim:" 这样用法是不行的。  
          冒号之间的部分是命令 ":set" 。它的用法就跟键入 ":set" 命令一一样,只除了在命令包                  含的任何冒号之前需要插入一个反斜杠 (否则该冒号就会被看成模式行结尾)。  

        // vim:set textwidth=72 dir=c\:\tmp: use c:\tmp here
                  在第一个冒号之前多一个反斜杠,因此它被包括在 ":set" 命令内。第二个冒号后面的文本则被        忽略不计,因此可以在那儿放个注释。




vim_user_manual.pdf 121页    