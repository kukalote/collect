# Vim查找与替换

## 1 查找命令及模式[^1]
[^1]: 来源 : Vim_reference.pdf 168页.

### 1.1.1 忽略大小写

```vim
:set ignorecase

//如果搜索时无大写字母，则大小写不敏感；如果含大写字母，则大小写敏感
:set ignorecase smartcase
```

**单个模式里的大小写**
在模式前添加 "\c" 字符串 : 仅想一次在模式里**忽略大小写**；
在模式前添加 "\C" 字符串 : 仅想一次在模式里**大小写敏感**。

模式 | 匹配
----|----
\CWord | Word
\cWord | word, Word, WORD...


### 1.1.2 在文件尾折返
回环匹配

```vim
:set wrapscan
```

### 1.2.1查找命令
`:?{pattern}[?偏移]`
`/{pattern}[/偏移]`
*tips:*[偏移](#偏移)

### 1.2.2 替换命令[^3]

[^3]: 来源 : Vim_reference.pdf 90页.

命令 | 表达式
----|--
替换 | `:[range]substitute/from/to/[flags]`

- `:substitute` 可以用 `:s` 代替。
- `%` 表示命令作用于全部行 ("1,$" 的缩写)。
- [flags] : 包含 (**g** [global, 全局])，(**p** [print, 打印]),(**c** [confirm, 确认]), (**e** [error, 无匹配不报错])

### 1.3.1 命令范围

1. 最简单的范围表达式是 "{number},{number}",例如 :

命令 | 说明
----|---
`:1,5s/this/that/g` | 这会从 1 行到 5 行上执行替换命令
`:54s/profession/foll/` | 替换指定行 (54行)
`:.,$s/yes/no/` | 要修改当前行到文件末的全部内容

### 1.3.2 在范围中使用模式
命令 | 说明
----|---
`:?^Chapter?,/^Chapter/s=grey=gray=g` | 这里使用了两个查找命令。第一个是 "?^Chapter?",用于查找前一个行首的 "Chapter"，就是说 "?pattern?" 用于向前查找。同样 "/^Chapter/" 用于向后查找下一章

### 1.3.3 加减法
标记 | 说明
----|---
`/Chapter/-1` | 查找一个模式，并且使用它的前 1 行
`/Chapter/+2` | 要定位匹配点下的第 2 行
`:.+3,$-5` | 指定当前行下面第 3 行到文件末尾倒数第 5 行的范围

### 1.3.4 使用标记

用 "**mt**" 标记开头，再用 "**mb**" 标记结尾。你可以用标记表示一个范围 (包括标记的那一行) :

标记 | 说明
----|---
`:'t,'b` | 从标记 t 到标记 b 的范围操作

### 1.3.5 可视模式和范围

可以在可视模式中选中一些行，再输入 ":" 启动冒号命令模式，会有 :
`:'<,'>`
还可以与其他标记混合使用 :

标记 | 说明
----|---
`:'<,'>` | 可视化选中区域
`:'>,$` | 选中区域至文件末尾

### 1.3.6 替换单词

标记 | 说明 | 替换范围
----|---|---
`:%s/four/4/g` | 替换文件中 four 为 4 | tfour、fourteen
`:%s/\<four/4/g` | 替换以 four 开头的单词 | fourteen
`:%s/\<four\>/4/g` | 替换文件中的单词 four | four

### 1.3.7 变量替换

标记 | 说明 | 替换范围
----|---|---
`:%s/\([^,]*\), \(.*\)/\2 \1/` | 将匹配的参 1 项与第 2 项重新组合 | Doe, John -> John Doe

*tips* : `\0` 表示整个匹配部分



### 1.4.1 偏移

匹配模式开始可以指定一个偏移，在正向查找命令 ”/“ 中指定偏移，就是在模式后面附加一个斜线符 (/) 以及偏移值 :

```vim
/默认/N
```
**字符偏移**
偏移符 "e" 表示一个偏移从匹配末尾算起。它把光标移到匹配的最后一个字符上。

```vim
//把光标放到单词 "const" 的 "t" 上。
/const/e
```
加一个数字，光标就从该位置再前移该数字指定的那么多个字符。下面会将光标移到匹配后面第一个字符 :

```vim
/const/e+1
```
一个正数使光标右移，负数使其左移。例如 :

```vim
/const/e-1
```
如果偏移以 "b" 开头，那么光标就移到匹配模式的首位。

```vim
//光标移到匹配的首位，再住右移两个字符。因而落在字符 "n" 上。
/const/b+2
```
### 1.5.1 匹配重复性模式

1. 如果多次重复整个字符串，那么该字符串必须被组成一个项。组成一个项的方法就是在它前面加 **"\("**，后面加 **"\)"**。

	```vim
	//匹配 : stringstringstring
	/\(string\)*
	```
2. 要避免匹配空字串，使用 **"\+"**。表示前面一项可以被匹配一次或多次。

	```vim
	//匹配 : abb、abbbb
	/ab\+
	```
3. 要匹配一个可选项,用 **"\="**。

	```vim
	//匹配 "folder" 和 "folders", 这里 "s" 便是可选项
	/folders\=
	```
4. 指定重复次数

	要匹配某一项的特定次数重复，使用 "\{n,m}" 这样的形式。其中 "n" 和 "m" 都是数字。在它前面的那个项将被重复 "n" 到 "m" 次。

	```vim
	//匹配"abbb","abbbb"和"abbbbb"
	/ab\{3,5}
	```

	模式 | 匹配到的次数
	----|---
	`\{,4}` | 0,1,2,3,或 4次
	`\{3,}` | 3,4,5次，等等
	`\{0,1}` | 0 或 1，跟 **`\=`** 一样
	`\{0,}` | 0 次或多次，跟 **`*`** 一样
	`\{1,}` | 1 次或多次，跟 **`\+`** 一样
	`\{3}` | 3 次

5. 正则表达式 : 懒惰模式

	所有的重复项都是"贪婪"地匹配所能找到的字符.要尽可能少次数地重复一个项,使用"`\{-n,m}`"。

	```vim
	//将会匹配到 "abbb" 中的 "ab"
	/ab\{-1,3}
	```
	它永远都不会匹配多于一个的b,因为没理由做这样的匹配.要让它超出最低限定次数地重复必需要有其它的强制因素。

	对 "n" 或 "m" 一方缺角的情况也一样.甚至两个上下限都没有指定时也一样,如 **"\{-}"**.它匹配它前面的项**一次或0次**,尽可能地少.这个模式本身只可能匹配到0次.跟其它东西联合使用时这一功能十分有用。  
	```vim
	//它会匹配到"axbxb"中的"axb"
	/a.\{-}b
	```
### 1.5.2 多选一

在一个模式中的"或"操作符是**"`\|`"** :

```vim
//匹配到"foo"或者"bar"
/foo\|bar
```
要匹配多次,必需把整个字符串用"**`\(`**"和"**`\)`**"前后括起来 :

```vim
//匹配到"foo","foobar","foofoo","barfoobar",等等
/\(foo\|bar\)\+
```
### 1.6.1 字符范围

如果你要匹配的是从**"a"到"z"**的所有26个字母，表示法 :

```vim
/[a-z]
```
**[]**这种结构只匹配到一个单个的字符.在括号中你可以指定哪些字符可以被匹配到.你可以指定一个字符列表,象这样

```vim
/[0123456789abcdef]
/[0-9a-f]
```

#### 1.7.1 使用 函数< line('.') >
`\=`其实就是对`\=`之后的表达式求值用来做替换。`line('.')`是一个返回数值的函数，返回当前行的行号，所以每一行的行号被作为`\=`的返回值，用来替换X，就得到了需要的结果。

```vim
This is number X
This is number X

> :%s/X/\=line('.')

=> This is number 1
=> This is number 2

> :%s/X/\=line('.')*line('.')

=> This is number 1
=> This is number 4

> :%s/X/\=printf("%03d", line('.'))

=> This is number 001
=> This is number 002
```


### 1.7.2 \%[]
一个可选匹配原的序列。它总能匹配，但试图匹配尽量多的列出的匹配原，而在第一个不匹配的地方终止。

```vim
//匹配 "r", "re", "rea", "read"
/r\%[ead]
```
`[]` 里不能有 `\(\), \%(\), \z(\) 项, \%[]` 也不能嵌套。
要包含 "**[**", 用 "**[[]**" 而 "**]**" 则可用 "**[]]**" ,例如：

```vim
//匹配 "index", "index[", "index[0", "index[0]"
/index\%[[[]0[]]]
=> 按上面转换后为 ： /index\%[[0]]
```

-----

### 1.8.1 经典示例

        :s/`\*`(.*)/\1`*`/g	
        // > `*`替换文本 
        // => 替换文本`*`

        :.,$s/^\([^$]*\)$\n^\([^$]*\)$/\1 | \2/
        // > 这是第一行
        // > 这是第二行
        // => 这是第一行 | 这是第二行 

        /folder\=
        //匹配 folder 和 folders

        /a.\{-}b
        //\{-}尽可能少的匹配，可以等于大于零


## 2. 表达式中指定部分作用[^2]
[^2]: 来源 : Vim_reference.pdf 863页.

1. 表达式匹配

	表达式 | 意义
---|---
^ | 行首
$ | 行尾
. | 匹配任何单个字符，不包括行尾符
`\i` | 标识符字符
`\I` | 同 "`\i`",但不包括数字字符
`\k` | 关键字字符
`\K` | 同 "`\k`", 但不包括数字字符
`\f` | 文件名字符
`\F` | 同 "`\f`", 但不包括数字字符
`\p` | 可显示字符
`\P` | 同 "`\p`", 但不包括数字字符
**备注** | 上面这些适用于多字节字符，而下面只匹配 ASCII 字符，因为它们由范围限定。
`\s` | 空白字符;`<Space>` 和 `<Tab>`
`\S` | 非空白字符: \s 之反
`\d` | 数位 `[0-9]`
`\D` | 非数位 `[^0-9]`
`\x` | 十六进制数位 `[0-9A-Fa-f]`
`\X` | 非十六进制数位 `[^0-9A-Fa-f]`
`\o` | 八进制数位 `[0-7]`
`\O` | 非八进制数位 `[^0-7]`
`\w` | 单词字符 `[0-9A-Za-z_]`
`\W` | 非单词字符 `[^0-9A-Za-z_]`
`\h` | 单词首字符`[A-Za-z_]`
`\H` | 非单词首字符`[^A-Za-z_]`
`\a` | 英文字母字符 `[A-Za-z]`
`\A` | 非英文字母字符 `[^A-Za-z]`
`\l` | 小写字符 `[a-z]`
`\L` | 非小写字符 `[^a-z]`
`\u` | 大写字符 `[A-Z]`
`\U` | 非大写字符 `[^A-Z]`
**备注** | 使用匹配原比使用 [] 构造要快
**备注** | 字符类不使用 'ignorecase', "\c" 和 "\C" 的设定。
`\e` | `<Esc>`
`\t` | `<Tab>`
`\r` | `<CR>`
`\b` | `<BS>`
`\n` | 匹配行尾符
`~` | 匹配上次给出的替代字符串
`\(\)` | 一个由转义的括号括起来的模式
`\%(\)` | 一个由转义的括号括起来的模式
`\<和\>` | 其中包括完整的词
---|**数量评价**
`*` | 0或者更多
`\+` | 1或者更多
`\=` | 0或者1
`\?` | 0或者1

2. [偏移用来指定光标相对于找到的匹配的位置](id:偏移)

    偏移表达式 | 效果
    ----|---
    `[num]` | [num] 行向下，第一列
    `+[num]` | [num] 行向下，第一列
    `-[num]` | [num] 行向上，第一列
    `e[+num]` | [num] 字符向右 (从匹配结束 end 处算起)
    `e[-num]` | [num] 字符向左 (从匹配结束 end 处算起)
    `s[+num]` | [num] 字符向右 (从匹配开始 start 处算起)
    `s[-num]` | [num] 字符向左 (从匹配开始 start 处算起)
    `b[+num]` | [num] 等价于 `s[+num]` (从匹配开始 begin 处算起)
    `b[-num]` | [num] 等价于 `s[-num]` (从匹配开始 begin 处算起)
    `;{pattern}` | 开始另一项搜索

    如果给出了 '-' 或 '+' 但省略了 [num],会使用缺省的 1.



