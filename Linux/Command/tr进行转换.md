### Linux_用tr进行转换

`tr` 可以对来自标准输入的内容进行字符替换、字符删除以及重复字符压缩。它可以将一组字符变成另一组字符, 因此通常也被称为 **转换** (translate) 命令。

`tr` 只能通过 stdin (标准输入), 而无法通过命令行参数来接受输入。它的调用格式如下 : 

    tr [options] set1 set2
    
将来自 stdin 的输入字符从 set1 映射到 set2, 然后将输出写入 stdout (标准输出)。set1 和 set2 是字符类或字符集。如果两字符集的长度不相等, 那么 set2 会不断重复其最后一个字符, 直到长度与 set1 相同。如果 set2 的长度大于 set1, 那么在 set2 中超出 set1 长度的那部分字符则全部被忽略。

#### 工作原理

1. 将输出字符由大写转换成小写

        $ echo "HELLO WORLD" | tr 'A-Z' 'a-z'
    
    'A-Z' 和 'a-z' 都是集合。我们按照需要追加字符或字符类来构造自己定制的集合。
    
    > 'ABC-}'、 'aA.,'、 'a-ce-x' 以及 'a-c0-9' 等均是合法的集合。定义集合也很简单, 不需要去书写一长串连续的字符序列, 相反, 我们可以使用 "起始字符-终止字符" 这种格式。这种写法也可以和其他字符或字符类结合使用。如果 "起始字符-终止字符" 不是一个连续的字符序号, 那么它就会被视为一个包含了三个元素的集合 ("起始字符-终止字符")。你可以使用像 '\t'、'\n' 这种特殊字符, 也可以使用其他ASCII字符。
    
2. tr 删除字符,-d : 

    `tr` 有一个选项 `-d`, 可以通过指定需要被删除的字符集合, 将出现在 stdin 中的特定字符清除掉:
    
        $ cat file.txt | tr -d '[set1]'
        # 只使用 set1, 不使用 set2
        
    例如 : 
    
        $ echo "Hello 123 world 456" | tr -d '0-9'
        Hello world
        # 将 stdin 中的数字删除并打印出来
        
3. 字符集补集, -c

    我们可以利用选项 `-c` 来使用 set1 的补集。下面的命令中, set2 是可选的 : 
    
        tr -c [set1] [set2]
        
    set1 的补集意味着这个集合中包含 set1 中没有的所有字符。
    
    最典型的用法是从输入文本中将不在补集中的所有字符全部删除。例如 : 
    
        $ echo hello 1 char 2 next 4 | tr -d -c '0-9 \n'
        1 2 4 
        
    在这里, 补集中包含了除数字、空格字符和换行符之外的所有字符。因为指定了 `-d`, 所以这些字符全部都被删除。
    
4. 用 tr 压缩字符, -s : 

    `tr` 命令在很多文本处理环境中大有用武之地。多数情况下, 连续的重复字符应该压缩成单个字符。经常需要从事的一项任务就是压缩空白字符。
    
    `tr` 的 `-s` 选项可以压缩输入中重复的字符, 方法如下 : 
    
        $ echo "GNU is   not   UNIX. Recursive  right ?" | tr -s ' '
        GNU is not UNIX. Recursive right ?
        # tr -s '[set]'
        
5. 字符类

    `tr` 可以像使用集合一样使用各种不同的字符类, 这些字符类如下所示 : 
    
    - alnum : 字母和数字
    - alpha : 字母
    - cntrl : 控制(非打印)字符
    - digit : 数字
    - graph : 图形字符
    - lower : 小写字母
    - print : 可打印字符
    - punct : 标点符号
    - space : 空白字符
    - upper : 大写字母
    - xdigit : 十六进制字符
    
    可以按照下面的方式选择并使用所需的字符类 : 
    
        tr [:class:] [:class:]
        
    例如 : 
    
        tr '[:lower:]' '[:upper:]'

#### 实际应用

1. ROT13 加密算法

    通过在 `tr` 中使用集合的概念, 我们可以将字符从一个集合映射到另一个集合中。
    
        $ echo 12345 | tr '0-9' '9876543210'
        87654 # 已加密
        $ echo 87654 | tr '9876543210' '0-9'
        12345 # 已解密
        
    ROT13 是一个著名的加密算法。在 ROT13 算法中, 文本加密和解密都使用一个函数。ROT13 按照字母排列顺序执行 13 个字母的转换。 用 `tr` 进行 ROT13 加密 : 
    
        $ echo "tr came, tr saw, tr conquered." | tr 'a-zA-Z' 'n-za-mN-ZA-M'
        ge pnzr, ge fnj, ge pbadhrerq.
        $ echo "ge pnzr, ge fnj, ge pbadhrerq." | tr 'a-zA-Z' 'n-za-mN-ZA-M'
        tr came, tr saw, tr conquered.
        
    `tr` 还可以用来将制表符转换成空格 : 
    
        $ tr '\t' ' ' < file.txt
        
2. 用 tr 将文件中的数字列表进行求和 : 

        $ cat sum.txt
        1
        2
        3
        
        $ cat sum.txt | echo $[ $(tr '\n' '+' ) 0 ]
        6
    
    上面的命令中,  `tr` 用来将 '\n' 替换成 '+' , 因此我们得到了字符串 "1+2+3+", 但是在字符串的尾部多了一个操作符 + 。 为了抵消这个多出来的操作符, 我们再追加一个 0。 
    
    `$[ operation ]` 执行算术运算, 因此得到下面的字符串 : 
    
        echo $[ 1+2+3+0 ]
        
    不过最好我们再使用 `-s` 参数, 摈除多余的换行符 : 
    
        $ cat sum.txt | echo $[ $(tr -s '\n' '+') 0 ]
        
        