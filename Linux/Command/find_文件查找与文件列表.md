### find 文件查找与文件列表

`find` 命令的工作方式如下: 沿着文件层次结构向下遍历, 匹配符合条件的文件, 并执行相应的操作。

要列出当前目录及子目录下所有的文件和文件夹, 可以采用下面的写法 : 

	$ find base_path
	
bash_path 可以是任何位置 (如 /home/xun), `find` 会从该位置开始向下查找。

	$ find . -print # 打印文件和目录的列表
	
`-print` 指明打印出匹配文件的文件名 (路径)。当使用 `-print` 时, '\n' 作为用于分隔文件的定界符。
`-print0` 指明使用 '\0' 作为定界符来打印每一个匹配的文件名。当文件名中包含换行符时, 这个方法就有用武之地了。

下面介绍 `find` 的其他选项 : 

1. [根据文件名或正则表达式匹配搜索](#根据文件名或正则表达式匹配搜索)
2. [否定参数](#否定参数)
3. [基于目录深度的搜索](#基于目录深度的搜索)
4. [根据文件类型搜索](#根据文件类型搜索)
5. [根据文件时间进行搜索](#根据文件时间进行搜索)
6. [基于文件大小的搜索](#基于文件大小的搜索)
7. [删除匹配的文件](#删除匹配的文件)
8. [基于文件权限和所有权限的匹配](#基于文件权限和所有权限的匹配)
9. [执行find 执行命令或动作](#执行find 执行命令或动作)
10. [让 find 跳过特定的目录](#让 find 跳过特定的目录)


#### 1. [根据文件名或正则表达式匹配搜索](id:根据文件名或正则表达式匹配搜索)

选项 `-name` 的参数指定了文件名所必须匹配的字符串。我们可以将通配符作为参数使用。`*.txt` 能够匹配所有以 `.txt` 结尾的文件名。选项 `-print` 在终端中打印出符合条件 (例如 `-name`) 的文件名或文件路径, 这些匹配条件作为 `find` 命令的选项给出。

	$ find /home/xun -name "*.txt" -print
	
`find` 命令有一个选项 `-iname` (忽略字母大小写), 该选项的作用和 `-name` 类似, 只不过在匹配名字的时候会忽略大小写。

	$ ls 
	example.txt EXAMPLE.txt 
	$ find . -iname "example*" -print
	./example.txt
	./EXAMPLE.txt
	
如果想匹配多个条件中的一个, 可以采用 `OR` 条件操作 : 

	$ ls 
	new.txt some.jpg text.pdf
	$ find . \( -name "*.txt" -o -name "*.pdf" \) -print
	./text.pdf
	./new.txt
	
上面代码用 `\(\)` 用于将过滤条件作为一个整体进行匹配。

选项 `-path` 的参数可以使用通配符来匹配文件路径或文件。 `-name` 总是用于给定的文件名进行匹配。 `-path` 则将文件路径作为一个整体进行匹配。

	$ find /home/users -path "*slynux*" -print
	This will match files as following paths.
	/home/users/list/slynux.txt
	/home/users/slynux/eg.css
	
选项 `-regex` 的参数和 `-path` 的类似, 只不过 `-regex` 是基于正则表达式来匹配文件路径的。

正则表达式是通配符匹配的高级形式, 它可以指定文本模式。我们借助这种模式来匹配并打印文本。使用正则表达式进行文本匹配的一人典型例子就是从一堆文本中解析出所有的 Email 地址。一个 Email 地址通常采用 name@host.root 这种形式, 所以, 可以将其一般化为 `[a-z0-9]+@[a-z0-9]+.[a-z0-9]+` 。 + 指明在它之前的字符类中可以出现一次或多次。

下面的命令匹配 .py 和 .sh 文件

	$ ls 
	new.PY new.jpg test.py
	$ find . -regex ".*\(\.py\|\.sh\)$"
	./test.py
	
类似地, `-iregex` 用于忽略正则表达式的大小写。

	$ find . -iregex ".*\(\.py\|\.sh\)$"
	./new.PY
	./test.py
	
#### 2. [否定参数](id:否定参数)

`find` 也可以用 "!" 否定参数的含义。 

	$ find . ! -name "*.txt" -print
	
上面的 `find` 命令能够匹配所有不以 .txt 结尾的文件名。

#### 3. [基于目录深度的搜索](id:基于目录深度的搜索)

`find` 命令在使用时会遍历所有的子目录。我们可以采用深度选项 `-maxdepth` 和 `-mindepth` 来限制 `find` 命令遍历的目录深度。

如果只允许 `find` 在当前目录中查找, 深度可以设置为1; 当需要向下两级时, 深度可以设置为2;其他情况依次类推。

可以用 `-maxdepth` 指定最大深度。

	$ find . -maxdepth 1 -name "f*" -print
	
也可以用 `-mindepth` 设置最小深度。这个选项可以用来查找并打印那些距离起始路径一定深度的所有文件。例如, 打印出深度距离当前目录至少两个子目录的所有文件:

	$ find . -mindepth 2 -name "f*" -print
	./dir1/dir2/file1
	./dir3/dir4/f2
	
即使当前目录或 dir1 和 dir3 中包含有文件, 它们也不会被打印出来。

> -maxdepth 和 -mindepth 应该作为 find 的第三个参数出现。如果作为第 4 个或之后的参数, 就可能会影响到 find 的效率, 因为它不得不进行一些不必要的检查。例如, 如果 -maxdepth 作为第 4 个参数, -type 作为第三个参数, find 首先会找出符合 -type 的所有文件, 然后在所有匹配的文件中再找出符合指定深度的那些。但是如果反过来, 目录深度作为第 3 个参数, -type 作为第 4 个参数, 那么 find 就能够在找到所有符合指定深度的文件后, 再检查这些文件的类型, 这才是最有效的搜索之道。

#### 4. [根据文件类型搜索](id:根据文件类型搜索)

Unix 类系统将一切视为文件。文件具有不同的类型, 例如普通文件、目录、字符设备、块设备、符号链接、硬链接、套接字以及FIFO等。

`-type` 可以对文件搜索进行过滤。借助这个选项, 我们可以为 `find` 命令指明特定的文件匹配类型。

只列出所有目录 : 

	$ find . -type d -print
	
将文件和目录列出可不是个容易的事。不过有了 `find` 就好办了。例如, 只列出普通文件 : 
	
	$ find . -type f -print
	
只列出符号链接

	$ find . -type l -print
	
文件类型 | 类型参数
----|---
普通文件 | f
符号链接 | l 
目录 | d
字符设备 | c 
块设备 | b
套接字 | s
FIFO | p

#### 5. [根据文件时间进行搜索](id:根据文件时间进行搜索)

Unix/Linux 文件系统中的每一个文件都有三种时间戳 : 

 - 访问时间 (-atime) : 用户最近一次访问文件的时间。
 - 修改时间 (-mtime) : 文件内容最后一次被修改的时间。
 - 变化时间 (-ctime) : 文件元数据 (例如权限或所有权) 最后一次改变的时间。
 
-atime、 -mtime、 -ctime 可作为 `find` 的时间选项。它们可以用整数值指定, 单位是天。这些整数值通常还带有 - 或 + : - 表示小于, + 表示大于。

 - 打印出在最近 7 天内被访问过的所有文件 : 
 
		 $ find . -type f -atime -7 -print
		 
 - 打印出恰好在 7 天前被访问过的所有文件 : 
 
		 $ find . -type f -atime 7 -print
		 
 - 打印出访问时间超过 7 天的所有文件 : 
 
		 $ find . -type f -atime +7 -print
		 
以上单位是天, 还有其他一些基于时间的参数是以分钟作为计量单位。包括 : 

 - 访问时间 (-amin)
 - 修改时间 (-mmin)
 - 变化时间 (-cmin)

举例如下 : 
 - 打印出访问时间超过 7 分钟的所有文件 : 
	
    $ find . -type f -amin +7 -print
		
`find` 另一个漂亮的特别是 `-newer` 参数。使用 `-newer` , 我们可以指定一个用于比较时间戳的参考文件, 然后找出比参考文件更新的 (更近的修改时间) 所有文件。

比如, 找到比 file.txt 修改时间更近的所有文件 : 

	$ find . -type f -newer file.txt -print
	

#### 6. [基于文件大小的搜索](id:基于文件大小的搜索)

根据文件的大小, 可以这样搜索 : 

	$ find . -type f -size +2k # 大于 2KB 的文件

	$ find . -type f -size 2k #大小等于 2KB 的文件
	
除了 `k` 之外, 还可以用其他文件大小单元。

 - b : 块 (512 字节)
 - c : 字节
 - w : 字 (2 字节)
 - k : 1024 字节
 - M : 1024K 字节
 - G : 1024M 字节

#### 7. [删除匹配的文件](id:删除匹配的文件)

`-delete` 可以用来删除 `find` 查找到的匹配文件。

删除当前目录下所有的 .swp 文件 : 

	$ find . -type f -name "*.swp" -delete
	
#### 8. [基于文件权限和所有权限的匹配](id:基于文件权限和所有权限的匹配)

也可以根据文件权限进行文件匹配。列出具有特定权限的所有文件 : 

	$ find . -type f -perm 644 -print	#打印出权限为644的文件
	
`-perm` 指明 `find` 应该只匹配具有特定权限值的文件。

以 Apache Web 服务器为例。 Web 服务器上的 PHP 文件需要具有合适的执行权限。我们可以用下面方法找到那些没有设置好执行权限的 PHP 文件 : 

	$ find . -type f -name "*.php" ! -perm 644 -print
	
也可以根据文件的所有权限进行搜索。用选项 -user USER 就能够找出由某个特定用户所拥有的文件。

参数 USER 可以是用户名或 UID。

例如, 打印出用户 slynux 拥有的所有文件 : 

	$ find . -type f -user slynux -print

#### 9. [执行find 执行命令或动作](id:执行find 执行命令或动作)  
`find` 命令可以借助选项 `-exec` 与其他命名进行结合。 `-exec` 算得上是 `find` 最强大的特性之一。   

在前一节中, 我们用 `-perm` 找出了所有权限不当的 PHP 文件。这次的任务也差不多, 我们要将某位用户 (比如 root) 全部文件的所有权限更改成另一位用户 (比如 Web 服务器默认的 Apache 用户 www-data), 那么就可以用 -user 找出 root 拥有的所有文件, 然后用 `-exec` 更改所有权。

> 你必须以 root 用户的身份执行 find 命令才能够进行所有权的更改。

示例如下 : 

	$ find . -type f -user root -exec chown slynux {} \;
	
在这个命令中, `{}` 是一个与 `-exec` 选项搭配使用的特殊字符串。对于每一个匹配的文件, `{}` 会被替换成相应的文件名。例如, `find` 命令找到两个文件 test1.txt 和 test2.txt, 其所有者均为 slynux, 那么 `find` 就会执行 : 

	chown slynux {}
	
它会被解析为 chown slynux test1.txt 和 chown slynux test2.txt

> 有时候我们并不希望对每个文件都执行一次命令。我们更希望使用文件列表作为命令参数, 这样就可以少运行几次命令了。如果是这样, 可以在 exec 中命令 `+` 来代替。

另一个例子是将给定目录中的所有 C 程序文件拼接起来写入单个文件 all_c_files.txt。我们可以用 `find` 找到所有的 C 文件, 然后结合 `-exec` 使用 `cat` 命令 : 

	$ find . -type f -name "*.c" -exec cat {} \;>all_c_files.txt
	
`-exec` 之后可以接任何命令。 `{}` 表示一个匹配。对于任何匹配的文件名, `{}` 均会被该文件名所替换。

用下列命令将 10 天前的 .txt 文件复制到 OLD 目录中 : 

	$ find . -type f -mtime  +10 -name "*.txt" -exec cp {} OLD \;
	
`find` 命令同样可以采用类似的方法与其他命令结合起来。

> **-exec 结合多个命令**
> 我们无法在 `-exec` 参数中直接使用多个命令。它只能接受单个命令, 不过我们可以耍一个小花招。把多个命令写到一个 shell 脚本中 ( 例如 command.sh ), 然后在 `-exec` 中使用这个脚本 : 
> `-exec ./commands.sh {} \;`

`-exec` 能够同 `printf` 结合来生成有用的输出信息。

    $ find . -type f -name "*.txt" -exec printf "Text file: %s\n" {} \;
    
#### 10. [让 find 跳过特定的目录](id:让 find 跳过特定的目录)

在搜索目录并执行某些操作时, 有时为了提高性能, 需要跳过一些子目录。例如, 程序员会在版本控制系统 (如Git) 管理的开发源树中查找特定的目录, 源代码层级结构中的每个子目录里都会包含一个 .git 目录, 但并没必要搜索这些目录。将目录或文件从搜索过程中排除在外的技巧被称为 **修剪**, 其操作方法如下 : 

    $ find  devel/source_path  \( -name ".git" -prune \)  -o  \( -type f -print \)
    # Instead of \( -type -print \), 而是选择需要的过滤器
    
以上命令打印出不包括在 .git 目录中的所有文件的名称 (路径)。

`\( -name ".git" -prune \)` 的作用是用于进行排除, 指明了 .git 目录应该被排除在外, 而 `\( -type f -print \)` 指明了需要执行的动作。这些动作需要被放置在第二个语句块中 (打印出所有文件的名称和路径)。


