
### Linux_常用命令

**[命令目录](id:toc)**

命令 | 介绍
----|---
[cd](#cd) | 浏览目录
[pwd](#pwd) | 目录切换
[touch](#touch) | 创建一个空文件;修改现有文件的访问时间和修改时间。
[nl](#nl) | 计算文件中的行号
[cp](#cp) | 复制文件
[ln](#ln) | 链接文件
[mv](#mv) | 重命名文件
[rm](#rm) | 删除文件
[mkdir](#mkdir) | 创建目录
[rmdir](#rmdir) | 删除目录
------------------|**查看文件内容**
[stat](#stat) | 查看文件统计数据
[file](#file) | 查看文件类型
[cat](#cat) | 查看整个文件
[more](#more) |---
[less](#less) |---
[tail](#tail) | 查看部分文件
[head](#head) |---
------------------| **监控程序**
[ps](#ps) | 进程查看
[top](#top) | 实时监控
[killall](#killall) | 停止进程
------------------| **监控磁盘空间**
[mount](#mount) | 挂载磁盘
[umount](#umount) | 卸载磁盘
[df](#df) | 磁盘使用情况
[du](#du) | 显示目录的使用情况
[sort](#sort) | 数据排序
[grep](#grep) | 搜索数据
[zip](#zip) | 压缩数据
[tar](#tar) | 归档数据
------------------| **变量**
[printenv](#printenv) | 查看全局环境变量 
[set](#set) | 显示特定进程的环境变量
[export](#export) | 设置全局环境变量 
[alias](#alias) | 命令别名
------------------| **理解 Linux 文件权限**
[useradd](#useradd) | 添加新用户
[userdel](#userdel) | 删除用户
[修改用户系列命令](#moduser) usermod、passwd、chage | 修改用户
------------------| **[用户组操作](#group)**
[groupadd](#groupadd) | 创建新用户组 
[groupmod](#groupmod) | 修改用户组 
------------------| **[解码文件权限](#permission)**
[umask](#umask) | 设置文件默认权限
------------------| **[修改安全设置](#security)**
[chown](#chown) | 修改用户默认组
[chgrp](#chgrp) | 修改用户默认组
------------------| **[脚本的基础知识](#shall_base)**
[echo](#echo) | 显示消息
[read](#read) | 获取用户输入
[wc](#wc)| 对数据中的文本计数
[expr](#expr) | 数学计算
[bc](#bc) | 浮点解决方案
--------------------| [退出脚本](#退出脚本)
[核对退出状态](#核对退出状态)  |
[退出命令](#退出命令) |



#### [cd](id:cd) : 目录切换

**cd** 命令切换当前目录至dirName。

1. 返回切换之前的目录

        # cd -
        
2. 切换到当前目录的顶级目录 : 

        # cd ..//
        
3. 把上个命令的参数作为cd参数使用

        # cd !$


[返回目录](#toc)


#### [pwd](id:pwd) : 目录切换

**pwd** 是当前目录在文件系统内的确切位置。

    //显示出实际路径, 而非使用连接(link)路径
    # pwd -P
    //目录连接链接时，输出连接路径
    # pwd -L

[返回目录](#toc)



#### [nl](id:nl) : 计算文件中的行号

**nl** 命令linux系统中用来计算文件中行号。`nl` 可以将输出的文件内容自动的加上行号！其默认的结果与 `cat -n` 有点不太一样， `nl` 可以将行号做比较多的显示设计，包括位数与是否自动补齐 0 等等的功能。  

**命令参数** : 

    -b  ：指定行号指定的方式，主要有两种：    
        -b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；        
        -b t ：如果有空行，空的那一行不要列出行号(默认值)；        
    -n  ：列出行号表示的方法，主要有三种：        
        -n ln ：行号在萤幕的最左方显示；        
        -n rn ：行号在自己栏位的最右方显示，且不加 0 ；        
        -n rz ：行号在自己栏位的最右方显示，且加 0 ；    
    -w  ：行号栏位的占用的位数。    
    -p 在逻辑定界符处不重新开始计算。 

`nl` 命令读取 File 参数（缺省情况下标准输入），计算输入中的行号，将计算过的行号写入标准输出。 在输出中，`nl` 命令根据您在命令行中指定的标志来计算左边的行。 输入文本必须写在逻辑页中。每个逻辑页有头、主体和页脚节（可以有空节）。 除非使用 `-p` 标志，`nl` 命令在每个逻辑页开始的地方重新设置行号。 可以单独为头、主体和页脚节设置行计算标志（例如，头和页脚行可以被计算然而文本行不能）。

[返回目录](#toc)


#### [touch](id:touch) : 创建一个空文件
`touch` 命令创建一个您指定的新文件,并将您的用户名作为文件所有者。

**`Tips : `**  
文件大小为零,因为 `touch` 命令创建的是一个空文件。`touch` 命令还可以用于更改现有文件的访问时间和修改时间,而不改变文件的内容。

默认情况下,`touch` 使用当前时间。也可以指定时间,使用 `-t` 参数加上指定的时间戳。

    $ touch -t 200812251200 test
    $ ls -l test
    -rw-r--r--    1    rich    rich    0    Dec 25 2008    test1
[返回目录](#toc)

#### [cp](id:cp) : 复制文件
将文件和目录从文件系统的一个位置复制到另一个位置。  
`cp` 命令最基本的形式是使用两个参数 : 源对象和目标对象 :   
**`cp source destination`**

**cp 命令参数**

参数 | 描述
----|---
-a | 归档文件,保留其属性
-b | 为每个现有 destination 文件创建一个备份,而不是覆盖它
-d | 保留
-f | 强制覆盖现有 destination 文件,没有提示
-i | 覆盖 destination 文件前提示
-l | 创建文件链接而不是复制文件
-p | 保留文件属性 (如果可能) (***)
-r | 递归复制文件 (***)
-R | 递归复制目录 (***)
-s | 创建符号链接而不是复制文件
-S | 重写备份特性
-u | 仅在 source 文件的日期和时间比 destination 新时复制 source 文件(更新)
-v | 冗长模式,解释发生的事件
-x | 将复制限定在当前文件系统

[返回目录](#toc)

#### [ln](id:ln) : 链接文件
如果需要在系统中维护同一个文件的两个(或两个以上)副本,不一定要使用两个物理副本,可以使用一个物理副本和多个虚拟副本,这种虚拟副本称为 **链接**。链接是目录中的点位符,指向文件的真实位置。  

Linux 中有两种不同的文件链接类型 : 

- 符号链接 (又称软件链接);
- 硬链接。  

**硬链接** 创建一个单独的文件,其中包括有关源文件的信息和位置。引用该硬链接文件的效果跟引用源文件一样。

    $ cp -l test1 test4
    $ ls -il
    1954793 -rw-r--r-- 2 rich rich 0 Sep 1 09:51 test1
    1954793 -rw-r--r-- 2 rich rich 0 Sep 1 09:51 test4

在同一个物理介质的文件之间只能创建一个硬链接。不能在不同挂载点下的文件之间创建硬链接。在这情况下,您必须使用 **软链接**。

    $ cp -s test1 test5
    $ ls -il
    1954793 -rw-r--r-- 2 rich rich 6 Sep 1 09:51 test1
    1954891 lrwxrwxrwx 1 rich rich 5 Sep 1 09:56 test5 -> test1

**`Tips : `**  
新的 test5 文件的索引节点与 test1 文件不同,这表示 Linux 系统将其视为不同的文件。    
其次,文件大小不同。    
链接文件只需要存储有关源文件的信息,而不是文件中的实际数据。列表的文件名部分显示了这两个文件的关系。


[返回目录](#toc)


#### [mv](id:mv) : 重命名文件
在 Linux 中,重命名文件的过程称为 **移动**。mv 命令可以将文件和目录移动到另一个位置。  

**`Tips : `**   
移动文件将更改文件名但保留原来的索引节点号和时间戳。  
移动带有软链接的文件,其链接文件将不再是一个有效链接。    
使用硬链接指向的链接文件使用相同的索引节点号,没有问题。

[返回目录](#toc)

#### [rm](id:rm) : 删除文件

在使用 Linux 的过程中经常需要删除现有的文件。删除文件的目的可能是为了整理文件系统,也可能是为了重载软件包。  
bash shell 中移除文件的命令是 **rm**。
 
**`Tips : `** 该命令会提示您是否确定移除该文件。bash shell 中没有回收站。一旦移除文件则无法还原。

**`Tips : `** 关于链接源文件删除的问题 :   
删除链接源文件后，两个链接文件仍然可以显示。  
**硬链接** 文件仍然可以正常使用，内容也不会发生变化 : 硬链接文件使用的索引节点编号与源文件相同。在移除最后一个链接文件之前，硬链接文件将一直维护索引节点编号，并保留数据。  
**软链接** 文件底层文件不在了，那么链接指向的内容也消失了，链接文件名会用红色显示。

**rm 参数**

参数 | 描述
----|---
-i | 删除文件提示
-f | 无提示删除文件
-d | 删除目录(***)
-R | 删除目录下面的文件(可结合**-d**使用) (***)

[返回目录](#toc)


#### [mkdir](id:mkdir) : 创建目录

系统将创建一个新的目录并分配一个新的索引节点编号。

[返回目录](#toc)
#### [rmdir](id:rmdir) : 删除目录

默认情况下,rmdir 命令仅用于移除空目录。可以用 **--ignore-fail-on-non-empty** 参数移除非空目录。  

[返回目录](#toc)

#### [stat](id:stat) : 查看文件统计数据
**stat** 命令的结果可以显示目标文件的所有信息,甚至包括存储文件的设备的主设备号和次级设备号。  

[返回目录](#toc)
#### [file](id:file) : 查看文件类型

**file** 可以查看文件文件内部并确定文件类型。

**file** 命令将文件分为以下三类 :  
 
- 文本文件 : 包含可打印字符的文件;
- 可执行文件 : 可以在系统运行的文件;
- 数据文件 : 包括不可打印的二进制符的文件,但也不可以在系统运行。  

[返回目录](#toc)
#### [cat](id:cat) : 查看文本文件

**cat 参数**  

参数 | 描述
----|---
-n | 显示行号
-b | 只为非空行的行编号
-T | 用 `^T` 字符组合替换文本中的任何跳格符    

`cat` 可以将多个文件内容拼接在一起输出

    cat file1 file2
    
`cat` 还可以从标准输出中读取(下面代码中, `-`被用作为来自 stdin 文本的文件名。)

    echo 'helloworld' | cat -
    
    $ find . -type f -name "aa*" | cat
    ./201510235/vimwiki/aa:w.wiki
    $ cat `find . -type f -name "aa*"`
    = 1 级标题 =
    == 2 级标题 ==


 1. 压缩空白行  
    出于可读性或是虽的原因, 有时文本中的多个空行需要被压缩成单个。可以用以下的方法压缩文本文件中连续的空白行 : 
 
        $ cat -s file
    我们也可以用 `tr` 移除空白行 : 
    
        $ cat file | tr -s '\n'  
    在 `tr` 这种用法中, 它将连续多个 `\n` 字符压缩成单个 `\n`  
    
 2. 将文件中制表符标记为 `^I`  
    在一些语言中, 空格与制表符很难分开, 但有时各自又具有特殊含义, 需要进行区别对待。用 `cat` 命令的 `-T` 选项能够将其制表符标记成 `^I` : 
    
        $ cat -T ~/.vimrc
        
 3. 添加行号
    使用 `cat` 命令的 `-n` 选项会在输出的每一行内容之前加上行号。
    
        $ cat -n file

[返回目录](#toc)

#### [more](id:more) : 查看文本文件

**more**  是可控的文本文件查看命令。

**more 命令选项**

选项 | 描述
----|---
H | 显示帮助菜单
spacebar | 显示文本的下一页
`z` | 显示文件文本的下一页
`Enter` | 显示文本的下一行
`d` | 显示一半屏幕的文本
`q` | 退出程序
`s` | 向前跳过文本的下一行
`f` | 向前跳过一屏幕的文本
`b` | 向后跳过一屏幕的文本
`/expression` | 在文件中搜索 expression 代表的文本
`n` | 搜索上次指定的表达式中下一次出现的位置
`‘` | 转到指定的表达式第一次出现的位置
`!cmd` | 执行 shell 命令
`v` | 在当前启动 vi 编辑器
`Ctrl-L` | 在文件的当前位置重绘屏幕
`=` | 显示文件的当前行号
`.` | 重复上一个命令


[返回目录](#toc)

#### [less](id:less) : 查看文本文件

**less** 是 more 命令的升级版。

**less** 命令可以在命令读完整个文件之前显示文件内容,这项功能是 **cat** 和 **more** 命令所没有的,因而可以轻松应付大型文件。

[返回目录](#toc)

#### [tail](id:tail) : 显示文件尾部

**tail** 命令显示最后一组文件行。默认情况下,它显示文件的最后 10 行,但是也可以使用命令行参数更改该数字。

**tail 命令行参数**

参数 | 描述
----|---
`-c bytes` | 显示文件最后 bytes 个字节
`-n lines` | 显示文件最后 lines 行 (***)
`-f` | 保持 tail 程序的激活状态,并继续显示添加到文件的新行 (***)
`--pid=PID` | 与 -f 一起使用,跟踪文件直到进程 ID 为 PID 的进程终止 (***)
`-s sec` | 与 -f 一起使用,迭代之间休眠 sec 秒
`-v` | 始终显示给定文件名的输出标题
`-q` | 绝不显示给定文件名的输出标题 



[返回目录](#toc)

#### [head](id:head) : 显示文件头部

**head** 命令显示开头一组文件行。默认情况下,它显示文件的前 10 行。

**head** 参数查看 **tail** : 支持 `-c` 和 `-n` 参数不支持 `-f` 参数特性。


[返回目录](#toc)

#### [ps](id:ps) : 进程查看

当一个程序在系统中运行，就称为一个**进程**。

**ps 命令的 Unix参数 **  

参数 | 描述
----|---
`-A` | 显示所有进程
`-N` | 显示特定参数的结果的补集
`-a` | 显示除会话标题和无终端进程外的所有进程
`-d` | 显示除会话题外的所有进程
`-e` | 显示所有进程
`-C cmdlist` | 显示包含在 cmdlist 列表中的进程
`-G grplist` | 显示 grplist 列表中具有组 ID 的进程
`-U userlist` | 显示 userlist 列表中的 userid 拥有的进程
`-g grplist` | 根据会话或包含在 grplist 中的 groupid 来显示进程
`-p pidlist` | 显示 pidlist 列表中具有 PID 的进程
`-s sesslist` | 显示 sesslist 列表中具有会话 ID 的进程
`-t ttylist` | 显示 ttylist 列表中具有终端 ID 进程
`-u userlist` | 根据 userlist 列表占的有效 userid 来显示进程
`-F` | 使用额外完整输出
`-O format` | 显示 format 列表中的特定列和默认列
`-M` | 显示关于进程的安全信息
`-c` | 显示关于进程的额外调试信息
`-f` | 显示完整的格式列表 
`-j` | 显示作业信息
`-l` | 显示长列表
`-o format` | 只显示 format 中列出的特定列
`-y` | 不显示进程标记
`-Z` | 显示安全上下文信息
`-H` | 以层级格式显示进程(显示父进程)
`-n namelist` | 定义在 WCHAN 列中显示的值 
`-w` | 使用宽输出格式，使显示宽度不受限制
`-L` | 显示进程线程
`-V` | 显示 ps 的版本

**输出名词解释**
>- `UID` : 负责启动进程的用户；
- `PID` : 进程的 ID；
- `PPID` : 父进程的 PID (如果某个进程由另一个进程启动)
- `C` : 进程存续期的处理器利用率；
- `STIME` : 进程启动时的系统时间；
- `TTY` : 进程从中启动的终端设备；
- `TIME` : 运行进程所需的累计 CPU 时间；
- `CMD` : 启动程序的名称。
- `F` : 内核分配给进程的系统标记；
- `S` : 进程的状态 (O=在处理器上运行； S=睡眠； R=可运行，等待运行； Z=死进程，进程已禁止，但父进程不可用； T=进程已停止)；
- `PRI` : 进程的优先级 (数字越大表示优先级越低)；
- `NI` : nice value，用于判断优先级；
- `ADDR` : 进程的内存地址；
- `SZ` : 换出进程大致需要的交换空间；
- `WCHAN` : 进程睡眠时所在的内核函数的地址。


**ps 命令的 BSD 参数 **

参数 | 描述
----|---
`T` | 显示与该终端相关的所有进程
`a` | 显示与任何终端相关的所有进程
`g` | 显示包括会话标题在内的所有进程
`r` | 只显示正在运行的进程
`x` | 显示所有进程，包括未分配终端设备的进程
`U userlist` | 显示 userlist 列表中的 userid 拥有的进程
`p pidlist` | 显示在 pidlist 列表中的有 PID 的进程
`t ttylist` | 显示与 ttylist 列表中某个终端相关的进程
`O format` | 列出 format 中的具体列，与标准列一并显示
`X` | 以寄存器格式显示数据
`Z` | 在输出中包含安全信息
`j` | 显示作业信息
`l` | 显示长格式
`o` format | 只显示 format 中指定的列
`s` | 使用信号格式
`u` | 使用面向用户的格式
`v` | 使用虚拟内存格式
`N namelist` | 定义在 WCHAN 列中使用的值
`O order` | 定义显示信息列的顺序
`S` | 针对父进程中的子进程的合计数值信息，比如说 CPU 和内存使用率
`c` | 显示真实命令名称 (用于启动进程的程序名)
`e` | 显示命令使用的任何环境变量
`f` | 以层次结构显示进程，显示哪个进程启动了哪个进程
`h` | 不显示标题信息
`k sort` | 定义输出排序使用的列
`n` | 使用数值表示用户和组 ID ，以及 WCHAN 信息
`w` | 为较宽的终端生成宽输出 
`H` | 将线程作为进程显示
`m` | 在进程后显示线程
`L` | 列出所有格式说明符
`V` | 显示 ps 的版本

*名词解释*
> - `VSZ` : 进程在内存中的大小，以 KB 为单位；
- `RSS` : 进程使用过的且未被换出的物理内存；
- `STAT` : 由两个字符组成的状态码，用于表示当前进程的状态，第一个字符用与 Unix 类型的 S 输出列相同的值，显示进程正在睡眠、运行还是等待。第二个字符进一步定义进程的状态。
    - `<` : 进程正以高优先级运行。
    - `N` : 进程正以低优先级运行。
    - `L`  : 进程在内存中存在锁定页面。
    - `s` : 进程是会话领导者 (session leader)
    - `l` : 进程是多线程的。
    - `+` : 进程正在前台运行。

**ps 命令的 GNU 参数 **

参数 | 描述
----|---
`--deselect` | 显示在命令行中列出的进程之外的所有其他进程
`--Group grplist` | 显示组 ID 在 grplist 中列出的进程
`--User userlist` | 显示用户 ID 在 userlist 中列出的进程
`--group grplist` | 显示有效组 ID 在 grplist 中列出的进程
`--pid pidlist` | 显示进程 ID 在 pidlist 中列出的进程
`--ppid pidlist` | 显示父进程 ID 在 pidlist 中列出的进程
`--sid sidlist` | 显示会话 ID 在 sidlist 中列出的进程
`--tty ttylist` | 显示终端设备 ID 在 ttylist 中列出的进程
`--user userlist` | 显示有效用户 ID 在 userlist 中列出的进程
`--format format` | 只显示在 format 中指定的列
`--context` | 显示额外的安全信息
`--cols n` | 将屏幕宽度设置为 n 列
`--columns n` | 将屏幕高度设置为 n 行
`--cumulative` | 包含已停止子进程的信息
`--forest` | 在层次结构清单中显示进程，以显示父进程 (***)
`--headers` | 对每页输出重新列头 (column headers)
`--no-headers` | 不显示列头
`--lines n` | 将屏幕宽度设置为 n 列
`--rows n` | 将屏幕高度设置为 n 行
`--sort order` | 定义用于排序输出的列
`--width n` | 将屏幕宽度设置为 n 列
`--help` | 显示帮助信息
`--info` | 显示调试信息
`--version` | 显示 ps 程序的版本

[返回目录](#toc)


#### [top](id:top) : 实时监控

如果需要查明经常在内存中换进换出的进程的趋势,那么可以用 **top** 命令。

**输出格式**

>- 第一部分显示了一般系统信息。第一行显示了当前`时间`，系统`已正常运行的时间`，`已登陆用户数量`，以及`系统的平均负载`(平均负载包括3个值，分别是 1分钟、 5分钟和15分钟。值越大则系统负载越大。)。
 - 第二部分显示一般进程信息(在 `top` 中称为**任务**) : 有多少进程正在运行、睡眠、已停止和僵死(已运行完毕，但父进程未响应)。
 - 下一行显示 CPU 一般信息。`top` 命令会根据进程所有者 (用户或系统进程) 和进程的状态(运行、空闲和等待) 将 CPU 利用率划分成若干个类别。
 - 接下来的两行详细给出了系统内存的状态。第一行显示系统物理内存的状态，内存总量、当前使用的内存量和空闲内存量。第二行显示系统交换内存区域(如果已经安装)的状态，包括与前面相同的信息。
 - 最后，下一部分显示当前正在运行的进程的详细列表，显示信息如下：
	 - `PID` : 进程的 ID；
	 - USER : 进程所有者的用户名；
	 - PR : 进程的优先级；
	 - NI : 进程的 nice value；
	 - VIRT : 进程所使用的虚拟内存总量；
	 - RES : 进程当前正使用的物理内存量；
	 - SHR : 进程与其他进程共享的内存量；
	 - S : 进程状态(D=可中断睡眠， R=运行中， S=睡眠， T=已跟踪或已停止， Z=僵死)；
	 - %CPU : 进程正使用的 CPU 时间份额；
	 - %MEM : 进程正使用的可用物理内存份额；
	 - TIME+ : 进程启动后已使用的总 CPU 时间；
	 - COMMAND : 进程的命令行名称(已启动程序)。

**top 交互式命令**

命令 | 描述
----|---
`l` | 在单个 CPU 与 Symmetric Multiprocessor(SMP)状态之间切换
`b` | 启用表中重要数字粗体显示
`I` | 切换 Irix/Solaris 模式
`z` | 配置表的颜色
`l` | 切换平均负载信息行显示
`t` | 切换 cpu 信息行显示
`m` | 切换 MEM 和 SWAP 信息行显示
`f` | 添加或删除不同的信息列
`o` | 更改信息列的显示顺序
`F 或 0` | 选择对进程进行排序的字段 (默认为 %CPU)
`< 或 >` | 将排序字段左移 1 列 (<) 或右移 1 列 (>)
`r` | 在正常排序或反序排序之间切换
`h` | 切换线程显示
`c` | 切换显示进程的命令名或完整命令行 (包括参数)
`i` | 切换空闲进程显示
`S` | 切换显示累计 CPU 时间或相对 CPU 时间
`x` | 切换排序字段高亮显示
`y` | 切换运行中任务的高亮显示
`z` | 切换颜色和 mono 模式
`b` | 切换 x 和 y 模式的粗体模式
`u` | 显示特定用户的进程
`n 或 #` | 设置要显示进程的数量
`k` | 杀死特定的进程 (仅适用于进程所有者和根用户)
`r` | 更改特定进程的优先级 (renice) (仅适用于进程所有者和根用户)
`d 或 s` | 更改更新间隔 (默认为 3 秒)
`W` | 将当前设置写入配置文件
`q` | 退出 top 命令


[返回目录](#toc) 

#### [killall](id:killall) : 停止进程
`killall` 命令非常强大，它可以根据进程的名称 (而非 PID) 来停止进程。 killall 还允许使用通配符，它对于处理出错的系统非常有用。

[返回目录](#toc)

#### [mount](id:mount) : 挂载磁盘

Linux 文件系统将所有介质磁盘合并到一个虚拟目录中。使用新介质磁盘之前,需要将它放在一个虚拟目录中。这项任务称为 **挂载**。

`mount` 命令用于挂载介质。默认情况下，`mount` 命令显示系统当前挂载介质设备列表。

    $ mount    
`mount` 命令提供了 4 条信息 :   
>- 介质的设备位置；
- 介质在虚拟目录中的挂载点；
- 文件系统类型；
- 已挂载介质的访问状态。

要手动在虚拟目录中挂载介质设备，需要作为根用户登录。用于手动挂载介质设备的基本命令如下 : 

    mount -t type device directory
type 参数定义格式化磁盘的文件系统类型。Linux 可以识别许多不同的文件系统类型。如果需要与 Windows PC 共享可移动介质设备，则最可能的类型包括以下几种 :   
> - `vfat` : Windows 长文件系统。
- `ntfs` : Windows 高级文件系统，在 Windows NT、 XP 和 Vista 中使用。
- `iso9660` : 标准 CD-ROM 文件系统。

    mount -t vfat /dev/sdb1 /media/disk
要将设备 /dev/sdb1 上的 USB 记忆棒手动挂载到 /media/disk 位置。


**mount 命令参数**

参数 | 描述
----|---
`-a` | 挂载 `/etc/fstab` 中指定的所有文件系统
`-f` | 使 `mount` 命令模拟挂载某个设备，但并不实际挂载
`-F` | 和 `-a` 参数连用时，同时挂载所有文件系统
`-v` | 详细模式，解释挂载设备所需的所有步骤
`-I` | 不使用 `/sbin/mount.filesystem` 中的任何文件系统帮助类文件
`-l` | 自动为 ext2、ext3 或 XFS 文件系统添加文件系统标签
`-n` | 挂载设备，而不在 `/etc/mstab` 挂载设备文件中注册
`-p num` | 对于加密的挂载，从文件描述符 num 中读取 passphrase
`-s` | 忽略文件系统不支持的挂载选项
`-r` | 以只读方式挂载设备
`-w` | 以读写方式挂载设备 (默认) 、
`-L label` | 以指定的 label 挂载设备
`-U uuid` | 以指定的 uuid 挂载设备
`-O` | 和 `-a` 参数连用时，限制使用的文件系统集
`-o` | 在文件系统中添加特定选项

`-o` 选项允许使用一列逗号分隔额外选项挂载文件系统。常用的选项包括以下几列 : 

- `ro` : 以只读形式挂载;
- `rw` : 只读写形式挂载;
- `user` : 允许普通用户挂载文件系统;
- `check=none` : 挂载文件系统,而不执行完全性检查;
- `loop` : 挂载某个文件。

        mount -t iso9660 -o loop MEPIS-DVD——32.iso mnt


[返回目录](#toc)


#### [umount](id:umount) : 卸载设备

要移除可移动介质设备，应首先制裁它，再从系统中移除它。

    umount [directory | device]
`unmount` 命令允许通过设备位置或挂载目录名称来定义介质设备。如果设备中包含任何打开的文件,则系统将不允许卸载它。

    $ umount /home/rich/mnt
    
[返回目录](#toc)

#### [df](id:df) : 磁盘的使用情况

`df` 命令允许我们方便地查看所有已挂载磁盘的使用情况。

    $ df
`df` 命令显示每个包含数据的已挂载文件系统。该命令显示 : 

- 设备位置;
- 能保存的数据块数量 (第块 1024 字节)；
- 已使用的数据数量;
- 可用的数据块数量;
- 已使用空间的百分比;
- 设备挂载点。

`df` 命令也提供了一些不同的命令行参数,但大部分都很少使用。其中一个较为常用的参数是 `-h` 。它用于以可读取形式显示磁盘空间,通常使用 M 表示兆字节,使用 G 表示吉字节 : 

    $ df -h


[返回目录](#toc)

#### [du](id:du) : 显示目录的磁盘使用情况

`du` 命令显示特定目录的磁盘使用情况(默认为当前目录)。这是判断系统是否存在磁盘占用大户的快捷方法。

默认情况下,`du` 命令显示当前目录下的所有的文件、目录和子目录,并显示各文件或目录占用了多大空间。

`du` 命令提供了一些命令参数,可以提高清单的可读性 : 

- `-c` : 生成所有已列出文件的总计;
- `-h` : 以可读形式输出大小,使用 K 表示千字节, M 表示兆字节, G 表示吉字节。
- `-s` : 汇总各自变量。

[返回目录](#toc)

#### [sort](id:sort) : 数据排序

sort 命令的作用是对数据 (文件内容、合法输出) 进行排序。  

默认情况下,`sort` 命令使用您为会话指定的默认语言的标准排序规则对文本文件中的数据进行排序。

    $ sort file1
默认情况下,`sort` 命令将标准的字符排序;可以使用 `-n` 参数,按数字数字排序;还可以用参数 `-M`,即按月份排序。

**sort 命令参数**

单线 | 双线 | 描述
----|---|---
`-b` | `--ignore-leading-blanks` | 排序时忽略前面的空格
`-C` | `--check=quiet` | 不执行排序,但不报告灵气是否无序排列
`-c` | `--check` | 不执行排序,但检查数据是否已经排序。若未排序,则报告
`-d` | `--dictionary-order` | 只考虑空格和字母数字;不考虑特殊字符
`-f` | `--ignore-case` | 默认情况下,大写字母排在前面,此参数将忽略大小写
`-g` | `--general-numeric-sort` | 使用普通数值进行排序
`-i` | `--ignore-nonprinting` | 在排序中忽略非打印字符
`-k` | `--key=POS1[,POS2]` | 根据 POS1 位置进行排序,并在 POS2 位置结束 (如果指定了该参数) (***)
`-M` | `--month-sort` | 使用由 3 个字符组成的月份缩写按月份排序
`-m` | `--merge` | 合并两个已经执行排序的数据文件
`-n` | `--numeric-sort` | 按字符串数值进行排序
`-o` | `--output=file` | 将结果写入指定的文件
`-R` | `--random-sort` | 根据随机散列值排序
---|`--random-source=FILE` | 指定 -R 参数使用的随机字节文件
`-r` | `--reverse` | 反转排列(降序,而不是升序)
`-S` | `--buffer-size=SIZE` | 指定要使用的内存量
`-s` | `--stable` | 禁用 last-resort comparison
`-T` | `--temporary-direction` | 指定存储临时工作文件的位置
`-t` | `--field-separator=SEP` | 指定用于区分关键位置的字符 (***)
`-u` | `--unique` | 带 -c 参数,检查严格排序; 无 -c 参数,只输出两相似行中的第一行
`-z` | `--zero-terminated` | 使用 NULL 字符结束所有行,而不是换行符

    //以:分隔，对第三列进行数字排序
    $ sort -t ':' -k 3 -n /etc/passwd
    


[返回目录](#toc)
#### [grep](id:grep) : 搜索数据

经常需要查找大文件中的特定数据行。可以使用 `grep` 命令来完成搜索任务,而不必在整个文件手动查找。

`grep` 命令的命令行格式如下 : 

    grep [options] pattern [file]
`grep`  命令将在输入或指定的文件中搜索包含与指定模式 (pattern) 匹配的字符的数据行。`grep` 命令的输出是包含匹配模式的数据行。

如果想 **反转搜索** (输出不匹配模式的数据行),可以使用 `-v` 参数。 

    $ grep -v two file
    //查找不匹配 two 的行
如果希望获取与模式匹配的数据所在的 **行号**,可以使用 `-n` 参数。

    $ grep -n two file
    //显示匹配内容及行号
如果只想了解有多少行包含匹配模式,可以使用 `-c` 参数。
    
    $ grep -n two file
    //显示匹配内容有多少行
如果指定多个匹配模式,可以使用 `-e` 参数指定各模式。
     
     $ grep -e one -e two file
     //查找匹配 one 的行和匹配 two 的行
**`Tips : `** 默认情况下, grep 命令使用基本 Unix 类型的正则表达式来匹配模式。 Unix 类型的正则表达式使用特殊字符定义如何查找匹配模式。     
  
**`Tips : `** `egrep` 命令是 `grep` 命令的一个分支,允许指定 POSIX 扩展的正则表达式,即使多个字符指定匹配模式。

**`Tips : `** `fgrep` 命令则允许使用一列由换行符分隔的固定字符串值来指定匹配模式。允许将一列字符串放置在一个文件中,然后在 `fgrep` 命令中使用该列表搜索大文件中的字符串。


[返回目录](#toc)
#### [zip](id:zip) : 压缩数据

**Linux 文件压缩工具**

工具 | 文件扩展名 | 描述
----|---|---
bzip2 | .bz2 | 使用 Burrows-Wheeler 块排序文本压缩算法和 Huffman 编码
compress | .Z | 原 Unix 文件压缩工具；现在已经很少使用了
gzip | .gz | GNU 项目的压缩工具；使用 Lempel-Ziv 编码
zip | .zip | Unix 版本的 Windows PKZIP 程序 

 1. `bzip2` 工具是一个相对较新的压缩包，它在压缩大型二进制文件方面正日益普及。bzip2包中的工具包括以下几种 : 
      - bzip2 : 用于压缩文件；
      - bzcat : 用于显示已压缩文本文件的内容；
      - bunzip2 : 用于解压 .bz2 文件；
      - bzip2recover : 用于尝试恢复受损的压缩文件。
2. `gzip` 工具是 Linux 中最流行的文件压缩工具。包含以下文件 :   
      - gzip : 用于压缩文件；
      - gzcat : 用于显示压缩后的文本文件的内容；
      - gunzip : 用于解压文件。

3. `zip` 工具与 Windows 中创建的 PKZIP 包兼容。Linux zip 包中包含 4 个工具 : 
      - zip : 用于创建包含列出文件和目录的压缩文件。
      - zipcloak : 用于创建包含列出文件和目录的加密压缩文件。
      - zipnote : 用于提取 zip 文件中注释。
      - zipsplit : 用于将 zip 文件分割成指定大小的多个小文件。
      - unzip : 用于提取压缩 zip 文件中的文件和目录。



[返回目录](#toc)



#### [tar](id:tar) : 归档数据

`tar` 命令用于将文件归档到磁带设备中。但是，它还可以将输出写入到文件中，

    tar function [options] object1 object2

**function** 参数定义 `tar` 命令的职责,如 :    
**tar 命令功能**

功能 | 长名称 | 描述
----|---|---
`-A` | `--concatenate` | 将已有 tar 归档文件添加到另一个已有归档文件中
`-c` | `--create` | 创建一个新 tar 归档文件 
`-d` | `--diff` | 检查 tar 归档文件和文件系统之间的差异
---| `--delete` | 从已有 tar 归档文件中删除
`-r` | `--append` | 将文件添加到已有 tar 归档文件的末尾
`-t` | `--list` | 列出现有 tar 归档文件的内容
`-u` | `--update` | 更新现有 tar 归档文件中的文件 
`-x` | `--extract` | 解压现有归档文件

各功能使用 **选项** 定义 `tar` 归档文件的特定行为   
**tar 命令选项**

选项 | 描述
----|---
`-C dir` | 到指定目录
`-f file` | 输出结果到文件 (或设备) file
`-j` | 将输出重定向 bzip2 命令进行压缩
`-p` | 保留所有文件权限
`-v` | 在处理过程中列出文件 
`-z` | 将输出重定向到 gzip 命令进行压缩

    tar -cvf test.tar test/ test2/
    //创建一个名为 test.tar 的归档文件,其中包含 test1 目录和 test2 目录的内容。
    
    tar -tf test.tar
    //这将列出(但不解压) tar 文件 test.tar 的内容
    
    tar -xvf test.tar
    //这将解压 test.tar 文件的内容。如果 tar 文件在创建时拥有目录结构,则整个目录结构将在当前目录中被重建。
    
**`Tips : `** 如果看到以 `.tgz` 结尾的文件名。它们是经过 `gzip` 压缩的 `tar` 文件,可以使用 `tar -zxvf filename.tgz` 对它们进行解压。

[返回目录](#toc)
 




	



#### [printenv](id:printenv) : 查看全局环境变量 

Linux 系统会在开始 bash 会话时设置一些全局环境变量。系统环境变量始终使用全大写字母来区别于普通用户环境变量。
    
    $ printenv
如果显示单个环境变量的值,请使用 echo 命令。
    
    $ echo $HOME
    
[返回目录](#toc)

#### [set](id:set) : 显示特定进程的环境变量 

`set` 命令显示特定进程的所有环境变量集。但是,这其中也包括全局环境变量。还有一些额外的变量,它们是 **本地环境变量**。

    set
[返回目录](#toc)

#### [export](id:export) : 设置全局环境变量 

全局环境变量在任何由设置全局环境变量的进程创建的子进程中都可见。创建全局环境变量的方法是创建一个本地环境变量,然后再将它导出到全局环境中。  
这将通过使用 `export` 命令来完成 : 

    $ echo $test
    testing a long string
    $ export test
    $ bash
    $ echo $test    //子进程中显示变量内容
    testing a long string

[返回目录](#toc)

#### [alias](id:alias) : 使用命令别名  

**命令别名** 允许你为公共命令 (以及它们的参数) 创建别名, 以尽可能减少录入工作。  
查看别名列表 :   

    $ alias -p

**命令别名** 与本地环境变量的行为相似。它们只对于定义范围内的 shell 进程有效 :  

    $ alias li='ls -il'
    $ bash 
    $ li 
    bash : li : command not found
在启动新的交互式 shell[^1] 时, bash shell 始终会读取 `$HOME/.bashrc` 启动文件。这是放置 **命令别名** 语句的绝佳位置。
[^1]: 请看 <linux_设置环境变量.md> 篇

[返回目录](#toc)

#### [useradd](id:useradd) : 添加新用户

`useradd` 是用于将新用户添加到 Linux 中的主要工具。  
`useradd` 命令使用系统默认值结合命令行参数来定义用户账户。要查看 Linux 发行版所使用的系统默认值,请输入带 `-D` 参数的 `useradd` 命令 :   

    $ /user/sbin/useradd -D
输出字段分析 : 

- 新用户将被添加到用户组 ID 为 100 的公共用户组中。
- 新用户将在 `/home/loginname` 目录下创建一个 HOME 账户。
- 当密码逾期时, 账户将不会被禁用。
- 新账户不会在设定日期被设置为逾期。
- 新账户将使用 bash shell 作为默认 shell。
- 系统会将 `/etc/skel` 目录中的内容复制到用户的 HOME 目录。
- 系统将在邮件目录中创建一个文件用于账户接收邮件。

**useradd 命令行参数**

参数 | 描述(修改默认值加extra)
----|---
`-c comment` | 添加文本到新用户的注释字段
`-d home_dir` | 为主目录指定不同于登录名的名称 (extra)
`-e expire_date` | 指定账户将要逾期的日期, 采用 YYYY-MM-DD 格式 (extra)
`-f inactive_days` | 指定密码逾期后, 账户被禁用需要的天数。值 0 表示密码逾期时禁用账户; 值 -1 表示禁用此特性 (extra)
`-g initial_group` | 指定用户登录组的用户组名称或 GID (extra)
`-G group…` | 指定用户属于一个或多个补充用户组
`-k` | 将 `/etc/skel` 目录内容复制到用户的 HOME 目录 (还必须使用 -m )
`-m ` | 创建用户的 HOME 目录
`-M` | 不创建用户的 HOME 目录 (当默认设置为创建时使用)
`-n` | 使用与用户登录名相同的名称创建一个新用户组
`-r` | 创建一个系统账户
`-p passwd` | 为用户账户指定一个默认密码
`-s shell` | 指定默认登录 shell (extra)
`-u uid` | 为账户指定唯一的 UID


[返回目录](#toc)

#### [userdel](id:userdel) : 删除用户  

如果想从系统中删除用户, 需要使用 `userdel` 命令。默认情况下, `userdel` 只删除 `/etc/passwd` 文件中的用户信息。它不会删除账户在系统中拥有的任何文件。
 
如果使用 `-r` 参数, 则 `userdel` 将删除用户的 HOME 目录和用户的邮件目录。但是, 在系统中删除的用户账户可能仍拥有其他文件。

    $ /usr/sbin/userdel -r test
    已经没有 /home/test 这个目录了。
    
[返回目录](#toc)
#### [命令系列](id:moduser) : 修改用户 

1. **usermod**  
`usermod` 是最强大的用户账户修改实用工具。它提供了各种选项用于修改 `/etc/passwd` 文件中的大多数字段。

    这些参数大多与 `useradd` 参数相同
    - `-c` 用于修改注释字段; 
    - `-e` 用于修改逾期日期; 
    - `-g` 用于修改默认登录用户组; 
    - `-l` 用于修改用户账户的登录名; 
    - `-L` 用于锁定账户,使用户无法登录; 
    - `-p` 用于修改账户的密码;
    - `-U` 用于解除账户锁定,使用户能够登录。
2. **passwd** 和 **chpasswd**  
    `passwd` 命令可以用于快速修改用户的密码 : 
    
        $ passwd test
    系统中除了自己只有根用户可以修改自己的密码。
    
    如果需要对系统上的大量用户执行批量密码修改, 那么可以使用 `chpasswd` 命令。`chpasswd` 命令从标准输入读取登录名和密码对列表(由冒号分隔), 并自动对密码进行加密, 然后为用户账户设置它们。
    
3. **chsh、chfn** 和 **chage**   
`chsh`、`chfn` 和 `chage` 实用工具专用于特定的功能。  
`chsh` 命令允许快速修改用户的默认登录 shell。必须使用 shell 的完全路径名。

      $ chsh -s /bin/mysh user
`chfn` 命令提供了一个标准方法, 用于将信息存储到 `/etc/passwd` 文件的注释字段中。与只插入随机文本, 如名称、昵称, 或甚至保留注释字段为空的传统方式不同, `chfn` 命令使用在 Unix finger 命令中使用的具体信息来存储注释字段中的信息。finger  命令允许您方便地查找关于 Linux 系统上的用户信息。

       $ finger user
       Login: user       Name: user tset
       Directory: /home/user     shell: /bin/bash
       On since Thu Sep 20 18:03 (EDT) on pts/0 from 192.168.1.2
       No mail.
       No Plan.       
如果使用不带参数的 `chfn` 命令, 那么它将询问适合输入到注释字段中的值 :  

       $ chfn user
       Changing finger information for user.
       Name []: Ima Test
       Office []: Director of Technology
       Office Phone []: (123)555-1234
       Home Phone []: (123)555-9876
       
       Finger information changed.
       $ finger user
       Login: user
       Directory: /home/user        Name: Ima Test
       Office: Director of Technology    Office Phone: (123)555-1234
       Home Phone: (123)555-9876
       Never logged in.
       No Mail.
       No Plan.
所有的 `finger` 信息都整齐地保存在 `/etc/passwd` 文件条目中。
       
       $ grep user /etc/passwd
       user:x:504:504:Ima Test,Director of Technology,(123)555-1234,(123)555-9876:/home/user:/bin/bash
**chage 命令参数**

    参数 | 描述
----|---
`-d` | 设置距密码上次被修改时的天数
`-E` | 设置密码将逾期的日期
`-I` | 设置账户因密码逾期而被锁定后处于不活动状态的天数
`-m` | 设置两密码修改之间的最小间隔天数
`-W` | 设置警告消息在密码逾期前多少天出现

    可以采用以下两种方法来表示 `chage` 日期值 : 
    - YYYY-MM-DD 格式的日期;
    - 以数值表示的距 1970年 1 月 1 日的天数  
    
[返回目录](#toc)


#### [group](id:group) : 使用 Linux 用户组

用户账户对于控制各用户的安全性极为有效,但是它们在允许用户共享资源方面则稍有欠缺。为实现此目的, Linux 系统使用了另一个安全概念, 即 **用户组**。

用户组权限允许多个用户共享系统上某个对象的公共权限集, 例如文件、目录或设备。

每个用户组都有一个唯一的 **GID**。与 **UID** 类似, **GID** 是系统上独一无二的数值。除了 **GID** 之外, 每个用户组还有一个唯一的用户组名称。可以使用一些用户组实用工具来创建和管理自己在 Linux 系统上的用户组。

**/etc/group 文件**
与用户账户相同, 用户组信息存储在系统上的某个文件中。**/etc/group** 文件包含关于系统所使用的各用户组的信息。

与 **UID** 类似, **GID** 的分配需要使用特殊格式。用于系统账户的用户组将分配 `500` 以下的 **GID**, 而用户的用户组将从 `500` 开始分配 **GID**。

`/etc/group` 文件使用 4 个字段 : 

- 用户组名称;
- 用户组密码;
- GID;
- 属于用户组的用户账户列表。

通过使用密码, 用户组密码将允许非用户组成员临时成为用户组的成员。些特性并不常用, 但它确实存在。

**`Tips : `** 用户账户的列表可能会造成误导。您会注意到, 列表中的一些用户组并没有拥有任何用户。这不是因为它们没有任何成员。当用户使用某个用户组作为 `/etc/passwd` 文件里的默认用户组, 用户账户不会作为成员出现在 `/etc/group` 文件中。

[返回目录](#toc)


#### [groupadd](id:groupadd) : 创建新用户组 

`groupadd` 命令允许在系统中创建新用户组 : 

    $ /usr/sbin/groupadd shared
当创建新用户组时, 系统默认不会为它分配任何用户。 `groupadd` 命令并未提供将用户账户添加到用户组的选项。要添加新用户, 需使用 `usermod` 命令。  

    //为共享组添加rich成员
    $ /user/sbin/usermod -G shared rich
**`Tips : `** 在为用户账户指定用户组时需要格外小心。如果使用了 `-G` 参数, 则指定的用户组名称将替代用户账户的默认用户组。 `-G` 参数会将用户组添加到用户所属的用户组列表中, 以保证默认用户组的完整性。

[返回目录](#toc)


#### [groupmod](id:groupmod) : 修改用户组 

从 `/etc/group` 文件中可以看到, 其中并没有太多关于您要个性的用户信息。 `groupmod` 命令允许您 修改已有用户组的 `GID` (使用 `-g` 参数) 或用户组名称 (使用 `-n` 参数) : 

    $ /usr/sbin/groupmod -n sharing shared
在修改用户组的名称时, `GID` 和用户组成员将仍然保持不变, 仅有用户组名称会发生变化。由于所有安全性权限都基于 `GID`, 因此您可以随时修改用户组的名称, 而不会对文件的安全性造成不利的影响。  

[返回目录](#toc)

#### [permission](id:permission) : 解码文件权限 
**文件权限符号**  

    $ ls -l
    drwxrewxr-x 2 rich rich 4096 2007-09-03 15:12 test
    
输出清单中的第一个字段是描述文件和目录的权限的代码。字段中的第一个字符定义了对象的类型 : 

- `-` 表示文件;
- `d` 表示目录;
- `l` 表示链接;
- `c` 表示字符设备;
- `b` 表示块设备;
- `n` 表示网络设备。

在它后面是 3 组字符。每组的 3 个字符都定义一个访问权限 : 

- `r` 表示对象读取权限;
- `w` 表示对象写权限;
- `x` 表示对象执行权限。

如果拒绝了某个权限, 则该位置会出现一个破折号。这 3 组字符分别与 3 种级别的对象安全性相关 :   

- 对象的所有者;
- 拥有对象的用户组;
- 系统上的其他任何人。 


[返回目录](#toc)

#### [umask](id:umask) : 默认文件权限

`umask` 命令为您创建的任何文件或目录设置默认权限。  

`umask` 命令显示并设置默认权限 : 

    $ umask
    0022
    
**Linux 文件权限代码**  

权限 | 二进制 | 八进制 | 描述
----|---|---|---
`---` | `000` | `0` | 无权限
`--x` | `001` | `1` | 只要执行权限
`-w-` | `010` | `2` | 只有写入权限
`-wx` | `011` | `3` | 写入和执行权限
`r--` | `100` | `4` | 只有读取权限
`r-x` | `101` | `5` | 读取和执行权限
`rw-` | `110` | `6` | 读取和写入权限
`rwx` | `111` | `7` | 读取、写入和执行权限

`umask` 值是从对象完整权限集中减去的值。文件的完整权限是模式 `666` (所有人都读取/写入权限), 而目录的完整权限是 `777` (所有人都有读取/写入/执行权限)。  

`umask` 值通常设置在 `/etc/profile` 启动文件中。可以使用 `umask` 命令指定不同的默认 `umask` 设置。

    $ umask 026
    $ touch newfile2
    $ ls -l newfile2
    -rw-r----- 1 rich rich 0 Sep 20 19:46 newfile2
通过将 `umask` 值设置为 `026`, 默认文件权限将为 `640`, 因此, 新文件现在只允许用户组成员读取, 而系统上的其他人对该文件不具有任何权限。

由于目录的默认权限为 `777`, 因此通过 `umask` 生成的权限与新文件不同。`026` `umask` 值将从 `777` 中减去, 得出的目录权限设置为 `751`。

**`Tips : `** 这样看是有些麻烦且不易理解, 但就兼容性来看, 我们只是减去权限, 这样可以作用于权限值不同的单元而没有其他影响。
 
[返回目录](#toc)

#### [security](id:security) : 修改安全设置
#### [chmod](id:chmod) : 修改权限 

`chmod` 命令允许修改文件和目录的安全设置。`chmod` 命令的格式如下 : 

    chmod options mode file
    
`options` 参数提供了一些额外的特性来扩充 chmod 命令的行为 : `-R` 参数将循环执行文件和目录修改。您可以在指定文件名时使用通配符, 以便于在一个命令中修改多个文件的权限。

`mod` 参数允许您使用八进制或符号模式来设定安全设置。八进制模式设置相当简单; 只需根据需要为文件指定标准的 3 位八进制代码 : 

    $ chmod 760 newfile
    $ ls -l newfile
    -rwxrw---- 1 rich rich 0 Sep 20 19:16 newfile*

`chmod` 命令采取了与 3 组 3 个字符的普通字符串不同的方法。使用符号模式指定权限的格式如下 : 

    [ugoa…][[+-=][rwxXstugo…]]
第一组字符串定义了新权限适用对象 :   

- `u` 表示用户;
- `g` 表示用户组;
- `o` 表示其他(其他任何人);
- `a` 表示上述所有。

接下来, 使用一个符号表示您希望在已有权限中 : `添加权限(+)`, 从已有权限中`减去权限(-)`, 还是要`为权限赋值(＝)`。

最后, 第三个符号是为设置使用的权限。您可能会注意到, 其中并不仅包括普通的 rwx 值。其他的设置包括 : 

- `x` 用于指定执行权限, 仅当对象为目录或已经拥有执行权限时有效;
- `s` 用于设置正在执行的 UID 或 GID;
- `t` 用于保存程序文本;
- `u` 用于将权限设置为所有都的权限;
- `g` 用于将权限设置为用户组的权限;
- `o` 用于将权限设置为其他人的权限。
    
        //用户减去执行权限
        $ chmod u-x newfile
        //其他人加上读权限
        $ chmod o+r newfile


[返回目录](#toc)


#### [chown](id:chown) : 修改所有者 

`chown` 命令可以方便地修改文件的所有者。`chown` 命令的格式如下 : 

    chown options owner[.group] file
您可以为文件的新所有者指定登录名或数值 UID : 

    //修改文件用户为dan
    $ chown dan newfile
    
    //修改文件为rich用户组
    $ chown .rich newfile
    
    //修改文件用户及组
    $ chown dan.rich newfile
    
    //设置为与用户登录名相匹配的用户组名 test
    chown test. newfile
参数有 : `-R` 允许使用通配符对子目录和文件执行递归式修改。  
`-h` 参数还可以修改任何与文件具有符号关联的文件的所有者 :   
    只有根用户可以修改文件的所有者。任何用户都可以修改文件的默认用户组, 但用户必须是与修改操作相关的用户组中的成员。

[返回目录](#toc)


#### [chgrp](id:chgrp) : 修改用户默认组

`chgrp` 命令提供了一种简单的方法来仅修改文件或目录的默认用户组 :  

    $ chgrp shared newfile
    
 
[返回目录](#toc)
#### [shell_base](id:shell_base) : 脚本的基础知识 
>为什么要使用脚本 :   
命令行的最大字符数不超过 255 个字符。

创建 shell 脚本文件时, 必须在文件的第一行指明所使用的 shell。格式如下 :   

    #!/bin/bash

在普通的 shell 脚本中, 英镑符号 (#) 用作注释行。shell 不处理 shell 脚本中的注释行。但是, shell 脚本文件的第一行是个特例。用来指明shell。


#### [echo](id:echo) :  显示消息

`echo` 命令能显示一个简单的文本字符串 :   

    $ echo This is a test
    This is a test
**`Tips : `** 默认情况下不需要使用引号来标记想要显示的字符串。但如果在字符串中使用了引号, 有时会出现问题 : 

    $ echo Let's see if this'll work
    Lets see if thisll work    
`echo` 命令既可以用双引号也可以用单引号来标记文本字符串。如果要在字符串中使用它们, 需要在文本使用一种引号类型, 然后用另一种类型标记字符串 : 

    $ echo "This is a test to see if you're paying attention"
    his is a test to see if you're paying attention
    $ echo 'Rich says "scripting is easy".'
    Rich says "scripting is easy".

如果想要 `echo` 命令结果和 `echo` 文本字符串在同一行, 只需对 `echo` 语句使用 `-n` 参数即可。

如果在 `echo` 命令中包含这些字符 ( 例如制表符和换行符 ), 必须使用 `-e` 选项 : 

    echo -e "1.\tDisplay disk space"

[返回目录](#toc)


#### [read](id:read) : 获取用户输入

`read` 命令接受标准输入 (键盘) 的输入, 或其他文件描述符的输入。得到输入后, `read` 命令将数据放入一个标准变量中。

    #!/bin/bash
    
    echo -n "Enter your name: "
    read name
    echo "Hello $name, welcome to my program."
    
    $ ./testfile
    Enter your name: Kitty Ben
    Hello Kitty Ben, welcome to my program.
**`Tips : `** 生成提示的 `echo ` 命令使用了 `-n` 选项。该选项抵制字符串结尾的新行符, 允许脚本用户在字符串后面立即输入数据, 而不是在下一行中输入。

`read` 命令的 `-p` 选项, 允许在 `read` 命令行中直接指定一个提示符 :  

    #!/bin/bash
    
    read -p "Please enter your age:" age
    days=$[ $age * 365 ]
    echo "That makes you over $days days old!"
    
    $ ./testfile
    Please enter your age: 10
    That makes you over 3650 days old
`read` 命令也可以指定多个变量 :  
    
    #!/bin/bash
    
    read -p "Enter your name: " first last
    echo "Checking data for $last, $first.."
    
    $ ./testfile
    Enter your name: Brown john
    Checking data for john, Brown…
    
在 `read` 命令行中也可以不指定变量。如果不指定变量, 那么 `read` 命令会将接收到的数据放置在环境变量 REPLY 中 :  

    #!/bin/bash
    
    read -p "Enter a number: "
    factorial=1
    for (( count=1; count <= $REPLY; count++ ))
    do
        factorial=$[ $factorial * $count ]
    done
    echo "The factorial of $REPLY is $factorial"
    
    $ ./testfile
    Enter a number : 5
    The factorial of 5 is 120



获取用户输入要用 `read` 命令来完成。由于公期望字母输入, 因此最好是在 `read` 命令中使用 `-n` 选项仅获取一个字符。这允许用户输入一个数字而不必按 `Enter` 键 : 

    read -n 1 option


[返回目录](#toc)

#### [wc](id:wc) : 对数据中的文本计数

`wc` 命令对数据中的文本计数。默认情况下它生成 3 个值 : 

- 文本的行数;
- 文本的单词数;
- 文本的字数。

        $ wc < testfile
        2    11    60

 
[返回目录](#toc)

#### [expr命令](id:expr)

`expr` 命令允许处理命令行中的等式, 但是很笨拙。
    
    $ expr 1+5
    6
`expr` 命令能够区分一此坏同的数学操作符和字符串操作符, 如下表 :   
**expr 命令操作符**

操作符 | 描述
----|---
`ARG1 \| ARG2` | 如果两个参数都不为空或都不为0, 返回 ARG1; 否则, 返回 ARG2
`ARG1&ARG2` | 如果两个参数都不为空或都不为0, 返回 ARG1;否则, 返回 0
`ARG1<ARG2` | 如果 ARG1 小于 ARG2, 返回 1; 否则, 返回 0
`ARG1<=ARG2` | 如果 ARG1 小于等于 ARG2; 返回1, 否则, 返回0
`ARG1=ARG2` | 如果 ARG1 等于ARG2; 返回1;否则, 返回0
`ARG1!=ARG2` | 如果 ARG1 不等于 ARG2, 返回 1; 否则, 返回0
`ARG1>=ARG2` | 如果 ARG1 大于等于 ARG2, 返回1; 否则, 返回0
`ARG1>ARG2` | 如果 ARG1 大于 ARG2, 返回1; 否则, 返回0
`ARG1+ARG2` | 返回 ARG1 与 ARG2 的和
`ARG1-ARG2` | 返回 ARG1 与 ARG2 的差
`ARG1*ARG2` | 返回 ARG1 与 ARG2 的积
`ARG1/ARG2` | 返回 ARG1 与 ARG2 的商
`ARG1%ARG2` | 返回 ARG1 与 ARG2 的余
`STRING:REGEXP` | 如果 REGEXP 匹配 STRING 中的一个模式, 返回该模式
`match STRING REGEXP` | 如果 REGEXP 匹配 STRING 中的一个模式, 返回该模式
`substr STRING POS LENGTH` | 从 POS 位置起始(始于1), 返回长度为 LENGTH 字符
`index STRING CHARS` | 返回在 STRING 中找到 CHARS 的位置, 否则返回0
`length STRING` | 返回字符串 STRING 的长度
`+ TOKEN` | 将 TOKEN 解释为一个字符串, 即使它是一个关键字
`(EXPRESSION)` | 返回 EXPRESSION 值

**`Tips : `** shell 中许多 `expr` 命令操作符 (如星号) 有其他含义。在 `expr` 命令中使用它们会生成一些奇怪的结果 :   
    
    $ expr 5 * 2
    expr : syntax error
    
    要解决解析错误, 可以用shell转义字符 (反斜杠)
    $ expr 5 \* 2
    10

[返回目录](#toc)
#### [浮点解决方案](id:bc)

克服整数限制的解决方案, 最普遍的解决方法是内置的 bash 计算器 (称为 `bc`)。

1. **浮点解决方案**
bash 计算器实际上是一种编程语言, 该语言允许在命令 行中输入浮点表达式, 然后解释表达式并计算它们, 最后返回结果。bash 计算器可以识别 : 

    >   - 数字 (整数和浮点)
    - 变量 (简单变量和数组)
    - 注释 (以英镑符号开始的行或 C 语言的/**/对)
    - 表达式
    - 编程语句 (如 if-then 语句)
    - 函数  

        $ bc
        $ 12 * 5.4
        64.8
        $ quit
浮点算术被称为 `scale` 的内置变量控制, 默认值为 0。必须把这个值设置为想要的十进制小数位数, 否则得不到想要的结果 :   
        
        $ bc -q
        $ 3.44 / 5
        0
        $ scale=4
        $ var1 = 3.44 / 5
        $ print var1
        .6880
        $ quit
2. **脚本中使用 bc**
**可以用反引号运行 `bc` 命令, 并且把输出赋值给一个变量**。 使用格式为 : 

        variable=`echo "options; expression" | bc`
第一部分 `options` 允许设置变量。如果需要设置多个变量, 使用分号将它们隔开。 `expression` 参数定义了使用 `bc` 计算的数学表达式。这看起来有点怪, 但它运行起来很快。

        #!/bin/bash
        var1=`echo " scale=4; 3.44 / 5 " | bc`
        echo $var1    //.6880
**在 shell 脚本中定义的变量** : 
        
        #!/bin/bash
        var1=100
        var2=45
        var3=`echo "scale=4; $var1 / $var2" | bc`
        echo $var3    //2.2222
**还可以使用内置输入重定向方法, 而不使用文件重定向。**内置重定向允许从命令行直接重定向数据。在 shell 脚本中, 可以把输出赋值给变量。如下 :   

        variable=`bc << EOF
        options
        statements
        expressions
        EOF
        ` 
示例如下 :   
        
        #!/bin/bash
        var1=10.46
        var2=43.67
        var3=33.2
        var4=71
        
        var5=`bc << EOF
        scale = 4
        a1 = ( $var1 * $var2 )
        b1 = ( $var3 * $var4 )
        a1 + b1
        EOF
        `
        echo $var5    //2813.9882
**`Tips : `** 在 bash 计算器中可以给变量赋值。但在 bash 计算器内创建的变量只在 bash 计算器内有效, 而不能用在 shell 脚本中。
        
[返回目录](#toc)
#### [退出脚本](id:退出脚本)
为向 shell 表明, 命令已经处理完毕, 每条运行在 shell 中的命令都使用一个 **退出状态**。 这个退出状态是一个介于 0 和 255 之间的整数值, 当命令运行完成时, 命令就会把退出状态传递给 shell 。可以捕捉这个值并在您的脚本中使用它。

#### [核对退出状态](id:核对退出状态)
Linux 提供 `$?` 特殊变量来保存最后一条命令执行结果的退出状态。如果核对一条命令的退出状态, 必须在这条命令运行完成之后立即查看或使用变量 `$?`。 它会改变为 shell 执行的最后一条命令的退出状态值 :  

    $ date
    xxxx
    $ echo $?
    0
**`Tips : `** 按照惯例, 一条命令成功完成的退出状态是 0。如果命令执行错误, 那么退出状态就会是一个正整数 :   

    $ asdfg
    -bash : asdfg: command not found
    $ echo $?
    127
**Linux 退出状态代码**

代码 | 描述
----|---
0 | 命令成功完成
1 | 通常的未知错误
2 | 误用 shell 命令
126 | 命令无法执行
127 | 没找到命令
128 | 无效的退出参数
128+x | 使用 Linux 信号 x 的致命错误
130 | 使用 Ctrl-C 终止命令
255 | 规范外的退出状态

[返回目录](#toc)

#### [退出命令](id:退出命令)
`exit` 命令允许在脚本结束时, 指定一个退出状态 : 

    $ cat testfile
    #!/bin/bash
    var1=10
    var2=30
    var3=$[ $var1 + $var2]
    echo $var3
    exit 5

    $ ./testfile
    40
    $ echo $?
    5

退出状态码也可以与变量使用 : 

    exit $var
**`Tips : `** 退出状态码只能在 0～255 范围之内。shell 通过使用模计算做到了这一点。一个值的模是除操作之后的余数。运算结果就是那个特定的数被 256 除了之后的余数。
    
    
    $ exit 300
    $ echo $?
    44
[返回目录](#toc)

