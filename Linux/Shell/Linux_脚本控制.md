### Linux_脚本控制

### 13  [脚本控制](id:toc)

到目前为止, 我们运行脚本的唯一方式是以实时模式直接从命令行界面运行。这不是在 Linux 中运行脚本的唯一方式。还有很多可用的其他选项可以在 Linux 系统上运行 shell 脚本。另外, 有时脚本会遭遇循环中止问题, 需要找出如何在不关闭 Linux 系统的情况下停止这段脚本。



- 13.1 [处理信号](#处理信号)
    - 13.1.1 [Linux 信号回顾](#Linux 信号回顾)
    - 13.1.2 [生成信号](#生成信号)
    - 13.1.3 [捕获信号](#捕获信号)
    - 13.1.4 [捕获脚本退出](#捕获脚本退出)
    - 13.1.5 [移除捕获](#移除捕获)

- 13.2 [以后台模式运行脚本](#以后台模式运行脚本)
    - 13.2.1 [以后台模式运行](#以后台模式运行)
    - 13.2.2 [运行多个后台作业](#运行多个后台作业)
    - 13.2.3 [退出终端](#退出终端)

- 13.3 [在不使用控制台的情况下运行脚本](#在不使用控制台的情况下运行脚本)

- 13.4 [作业控制](#作业控制)
    - 13.4.1 [查看作业](#查看作业)
    - 13.4.2 [重新启动停止的作业](#重新启动停止的作业)

- 13.5 [变得更好](#变得更好)
    - 13.5.1 [nice 命令](#nice 命令)
    - 13.5.2 [renice 命令](#renice 命令)

- 13.6 [准确无误地运行](#准确无误地运行)
    - 13.6.1 [使用 at 命令调度作业](#使用 at 命令调度作业)
    - 13.6.2 [使用 batch 命令](#使用 batch 命令)
    - 13.6.3 [调度定期脚本](#调度定期脚本)

- 13.7 [从头开始](#从头开始)
    - 13.7.1 [在启动时启动脚本](#在启动时启动脚本)
    - 13.7.2 [随新 shell 一起启动](#随新 shell 一起启动)



#### 13.1 [处理信号](id:处理信号)

Linux 使用信号与系统上运行的进程进行通信。可以使用这些信号控制 shell 脚本的运行, 只需要让 shell 脚本在接收到来自于 Linux 系统的特定信号时执行命令即可。

##### 13.1.1 [Linux 信号回顾](id:Linux 信号回顾)

系统和应用程序可以生成 30 多个 Linux 信号。下表列出 Linux 编程中最常见的 Linux 系统信号 :  

**Linux 信号**

信号 | 值 | 描述
----|---|---
1 | SIGHUP | 挂起进程
2 | SIGINT | 中断进程
3 | SIGQUIT | 停止进程
9 | SIGKILL | 无条件终止进程数
15 | SIGTERM | 如果可能的话终止进程
17 | SIGSTOP | 无条件停止进程但不释放
18 | SIGTSTP | 停止或暂停进程, 但不终止于它
19 | SIGCOUNT | 重新启动停止进程

默认情况下, bash shell 会忽略它接收到的任何 `SIGQUIT(3)` 和 `SIGTERM(15)` 信号 ( 以防止交互的 shell  意外终止 )。但是, bash shell 处理它收到的任何 `SIGHUP(1)` 和 `SIGINT(2)` 信号。

如果 bash shell 收到了一个 `SIGHUP` 信号, 它会退出。在退出之前, 它将 `SIGHUP` 信号传递给 shell 启动的任意进程 (如 shell 脚本)。收到 `SIGNINT` 信号, shell 会立即中断。 Linux 内核停止向 shell 提供 CPU 上的处理时间。在这种情况下, shell 将 `SIGINT` 信号传递给由 shell 启动的任意进程以通知它们这种情况。

shell 将这些信号传递给 shell 脚本程序以对它们进行处理。 但是, 默认的 shell 脚本行为将忽略这些信号, 这样会对脚本运行产生不良影响。为了避免发生这样的情况, 可以对脚本进行编程以识别信号, 并执行命令以便脚本为信号结果做好准备。


[返回目录](#toc)

##### 13.1.2 [生成信号](id:生成信号)

Bash shell 可以使用键盘上的组合键生成两个基本的 Linux 信号。如果需要停止或暂时失控的程序, 那么这个功能就会派上用场。

1. **中断进程**
使用 `Ctrl + C` 组合键可以生成 `SIGINT` 信号, 并将其发送给当前正在 shell 中运行的任意进程。运行一个通常需要很长时间才能完成的命令并按 `Ctrl + C` 组合键 : 

        $ sleep 100
                    //这里按 Ctrl+C
        $
`Ctrl + C` 组合键不会在监视器上生成任何输出, 它只会停止当前在 shell 中运行的进程。

2. **暂停进程**
您还可以在过程中暂停进程而不终止它。   
`Ctrl + Z` 组合键生成 `SIGTSTP` 信号, 可以停止任何在 shell 中运行的进程。停止进程与终止进程不同, 停止进程后程序仍然留在内存中, 能够从停止的地方继续运行。

        $ sleep 10
                    //^Z
        [1]  + 652 stopped  sleep 10
方括号中的数字是 shell 分配的 **作业编号** (job number)。 shell 以 **作业** (job) 形式引用 shell 中运行的每个进程, 向每个作业分配唯一的作业编号。它向第一个启动的进程分配作业编号 1, 向第二个进程分配作业编号 2. ..

    不过在退出的时候会有警告提示 : 
    
        $ exit
        There are stopped jobs.
    我们可以按下面步骤来解决 :  
        
    - 用 ps 命令查看停止的作业 : 
    
            $ ps au
            USER   PID  %CPU %MEM      VSZ    RSS   TT  STAT STARTED      TIME COMMAND
            root   677   0.0  0.0  2432784    704 s000  R+   11:18上午   0:00.00 ps au
            xun    652   0.0  0.0  2432748    472 s000  T    11:10上午   0:00.00 sleep 10
            root   627   0.0  0.1  2466644   5596 s000  Ss   11:10上午   0:03.99 login -fp
    `ps` 命令停止作业的状态显示为 `T`, 表示该命令正被跟踪或者已经停止。
    - 如果想在停止作业仍处于活动状态时退出 shell, 只需要再次键入 `exit` 命令。 shell 将退出, 并终止停止的作业。还有一个方法, 就是用 `kill` 命令来发送一个 `SIGKILL` 信号来终止它的 PID : 
    
            $ kill -9 652
            [1]  + 652 killed     sleep 10


[返回目录](#toc)

##### 13.1.3 [捕获信号](id:捕获信号)

除了可以使用脚本忽略信号之外, 还可以在信号出现时捕获信号和执行其他命令。

`trap` 命令只可以指定能够通过 shell 脚本监控和拦截的 Linux 信号。如果脚本收到在 `trap` 命令中列出的信号, 它将保护信号不被 shell 处理, 并在本地处理它。

`trap` 命令的格式如下 : 

    trap commands signals
    
以下是一个使用 `trap` 命令忽略 `SIGINT` 和 `SIGTERM` 信号的简单示例 :   


    #!/bin/bash
    
    trap "echo you want to kill me ?" SIGINT SIGTERM
    echo "This is a test program"
    count=1
    while [ $count -le 10 ]
    do
        echo "Loop #$count"
        sleep 3
        count=$[ $count + 1 ]
    done
    echo "This is the end of the test program"
    
    $ ./testfile
    This is a test program
    Loop #1
    you want to kill me ?    //当试图使用 ^C 时，会有提示文字输出，但未中断执行
    Loop #2


[返回目录](#toc)

##### 13.1.4 [捕获脚本退出](id:捕获脚本退出)

除了在 shell 脚本中捕获信号之外, 还可以在 shell 脚本退出时捕获它们。这是一种在 shell 完成作业时执行命令的便捷方式。

要捕获 shell 脚本退出, 只需要向 `trap` 命令添加 `EXIT` 信号 :   
    
    #!/bin/bash
    
    trap "echo byebye" EXIT
    
    count=1
    while [ $count -le 3 ]
    do
        echo "Loop #$count"
        sleep 2
        count=$[ $count + 1 ]
    done
    echo "This is the end of the test program"
    
    $ ./testfile
    Loop #1
    Loop #2
    Loop #3
    byebye


[返回目录](#toc)

##### 13.1.5 [移除捕获](id:移除捕获)

要移除捕获, 使用破折号作为命令和想要恢复正常行为的信号列 :   

    #!/bin/bash
    
    trap "echo byebye" EXIT
    
    count=1
    while [ $count -le 3 ]
    do
        echo "Loop #$count"
        sleep 3
        count=$[ $count + 1 ]
    done
    trap - EXIT
    echo "I just removed the trap"
    
    $ ./testfile
    Loop #1
    Loop #2
    Loop #3
    I just removed the trap


[返回目录](#toc)

#### 13.2 [以后台模式运行脚本](id:以后台模式运行脚本)

使用 `ps` 命令, 可以看到 Linux 系统上运行着许多不同的进程。很明显, 所有这些进程都不是在终端监视器上运行的。这就是所谓的在 **后台** 运行进程。在后台模式中, 进程进行时与终端会话的 `STDIN`、 `STDOUT` 和 `STDERR` 无关。

您也可以使用 shell 脚本来利用该特性, 允许进程在后台运行而不锁定终端会话。

##### 13.2.1 [以后台模式运行](id:以后台模式运行)

要通过命令界面以后台模式运行 shell 脚本, 只需要在命令后加上一个 `&` 符号 :   

    $ ./testfile &
    [1] 973    //[作业编号] 进程的 Pid
这时, 可以在提示符处输出新的命令。但是, 后台进程仍在运行, 它仍然使用终端监视器显示 STDOUT 和 STDERR 消息。后台结束时, 它将在终端显示一条消息 : 

    [1]  - 973 done       ./testfile 


[返回目录](#toc)

##### 13.2.2 [运行多个后台作业](id:运行多个后台作业)

可以通过命令行提示符启动任何数量的后台作业 :  

    $ ./test1 &
    $ ./test1 &
    $ ./test1 &
    //多次执行后台作业
    
    $ pa au
    USER   PID  %CPU %MEM      VSZ    RSS   TT  STAT STARTED      TIME COMMAND
    xun   1686   0.0  0.0  2433432    956 s000  SN    5:20下午   0:00.00 sh ./test1
    xun   1680   0.0  0.0  2433432    956 s000  SN    5:20下午   0:00.00 sh ./test1
    xun   1680   0.0  0.0  2433432    956 s000  SN    5:20下午   0:00.00 sh ./test1
    //可以在进程输出列表中显示出来。


[返回目录](#toc)

##### 13.2.3 [退出终端](id:退出终端)

通过终端会话使用后台进程时必须非常小心。注意 `ps` 命令的输出, 每个后台进程都连接着一个终端会话 (pts/0) 终端。如果终端会话退出, 则后台进程也将退出。

如果与终端相关联的后台程序正在运行, 有些终端模拟器会发出警告, 而有些则不会。如果希望在注销控制台后脚本继续以后台模式运行, 则需要执行一些其他操作。


[返回目录](#toc)

#### 13.3 [在不使用控制台的情况下运行脚本](id:在不使用控制台的情况下运行脚本)

有时需要从终端会话启动 shell 脚本, 然后让脚本在结束之前以后台模式运行, 即使退出终端会话也是如此。可以使用 `nohup` 命令实现。

`nohup` 命令运行另一个命令阻塞发送到进程的任何 SIGHUP 信号。这可以防止在退出终端会话时退出进程。

`nohup` 命令的格式如下 : 

    $ nohup ./testfile &
    [1] 1725
    $ appending output to nohup.out
因为 `nohup` 命令将进程与终端断开, 所以进程没有 STDOUT 和 STDERR 输出链接。为了接收命令生成的任何输出, `nohup` 命令自动将 STDOUT 和 STDERR 消息重定向到称为 `nohup.out` 的文件。

**`Tips : `** 如果使用 `nohup` 运行另一个命令, 输出将添加到现有的 `ouhup.out` 文件。从同一个目录运行多个命令时要小心, 因为所有的输出都将发送到同一个 `nohup.out` 文件, 可能造成混淆。


[返回目录](#toc)

#### 13.4 [作业控制](id:作业控制)

前面介绍了使用 `Ctrl + Z` 组合键停止 shell 中运行的作业。停止作业后, Linux 系统会让您终止或重启它。可以使用 `kill` 命令终止进程。重启停止的进程需要向它发送 SIGCONT 信号。

重启、停止、终止和恢复作业的操作称为 **作业控制** (job control)。使用作业控制可以完全控制进程在 shell 环境中运行的方式。

##### 13.4.1 [查看作业](id:查看作业)

作业控制的关键命令是 `jobs` 命令。 `jobs` 命令可以查看 shell 处理的当前作业 :   

    #!/bin/bash
    
    echo "This is a test program $$"
    count=1
    while [ $count -le 10 ]
    do
        echo "Loop #$count"
        sleep 10
        count=$[ $count + 1 ]
    done
    echo "This is the end of the test program"
    
    $ ./testfile
    [1] + Stopped    ./testfile
    $ ./testfile > testout &
    
    $ jobs
    [2]  + Stopped    ./testfile
    [3]  - running    ./testfile > testout
两个作业启动后, 使用 `jobs` 命令查看分配给 shell 的作业。`jobs` 命令既可以显示停止的作业也可以显示运行的作业, 还包括作业编号以及作业中使用的命令。

**jobs 命令参数**

参数 | 描述
----|---
`-l` | 列出进程 PID 和 作业编号
`-n` | 仅列出自上一次 shell 通知以来已经更改了状态的作业
`-p` | 仅列出作业的 PID
`-r` | 仅列出运行的作业
`-s` | 仅列出停止的作业

**`Tips : `**    
>注意输出中的加号和减号。    
带有加号的作业被视为`默认作业`[^1]。如果命令行没有指定作业编号, 则它应该是任何作业控制登记引用的作业。  
带减号的作业是在处理完当前默认作业之后将成为默认作业的作业。  
在某一个时间点, 只能有一个带有加号的作业, 也只能有一个带有减号的作业, 无论 shell 中运行了多少作业。

[^1]:默认作业 : (前台最后结束的作业，或后台最后启动的作业)


[返回目录](#toc)

##### 13.4.2 [重新启动停止的作业](id:重新启动停止的作业)

在 bash 作业控制下, 能够以后台进程或前台进程的形式生jusr启动任何停止的作业。前台进程将控制正在处理的终端, 因此请谨慎使用该特性。

要以 *后台模式* 重新启动作业, 可以使用带有作业编号的 `bg` 命令。

    $ bg 2     //bg 作业编号
    [2]  - 2088 continued  ./trap.sh

要以 *前台模式* 重新启动作业, 可以使用带有作业编号的 `fg` 命令 : 

    $ fg 2    //fg 作业编号
    [2]  - 2145 continued  ./trap.sh
    。。。
我的是Mac 格式如下 : 

    $ bg #2    
    $ fg #2


[返回目录](#toc)

#### 13.5 [变得更好](id:变得更好)

在多任务操作系统 (包括 Linux) 中, 内核负责为系统中运行的每个进程分配 CPU 时间。实际上, CPU 中一次只能运行一个进程, 因此内核轮流流向每个进程分配 CPU 时间。

默认情况下, 从 shell 启动的所有进程在 Linux 系统上的 **调度优先级** (scheduling priority) 都相同。调度优先级是内核相对其他进程分配某个进程的 CPU 时间量。

调度优先级是一个整数值, 从 -20 (最高优先级) 到 +20 (最低优先级)。默认情况下, bash shell 启动所有优先级为 0 的进程。

这表明只需要一点处理时间的简单脚本与需要运行几个小时和复杂数学算法得到的 CPU 时间段相同。

有时需要更改特定命令的优先级, 可能要降低优先级以减少它占用的 CPU 资源, 还可能要提高优先级, 以便获得更多的处理时间。这可以使用 `nice` 命令实现。

##### 13.5.1 [nice 命令](id:nice 命令)

`nice` 命令可以在 **启动命令时** 设置它的调度优先级。要让命令在更低的优先级下运行, 只需要使用 `nice` 的 `-n` 命令行选项指定一个新的优先级水平 :   

    $ nice -n 10 ./testfile &
    $ ps al
      UID   PID  PPID CPU PRI NI      VSZ    RSS WCHAN  STAT   TT       TIME COMMAND
      501   596   339   0  16 10  2433432    956 -      SN   s001    0:00.01 sh ./testfile

**`Tips : `** `nice` 命令不允许普通系统用户增加登记的优先级。这是一个安全特性, 防止用户以高优先级启动所有命令。


[返回目录](#toc)

##### 13.5.2 [renice 命令](id:renice 命令)

有时需要更改 **已经在系统中运行** 的登记优先级。这就是 `renice` 命令的功能。它能够指定运行进程的 PID 以更改优先级 :  

    $ ./testfile &
    [4] 1388
    
    $ ps al 
    UID   PID  PPID CPU PRI NI      VSZ    RSS WCHAN  STAT   TT       TIME COMMAND
    501  1388   339   0  26  5  2433432    944 -      SN   s001    0:00.00 sh ./trap.sh
    
    $ renice 10 -p 1388
    
    $ ps al
    UID   PID  PPID CPU PRI NI      VSZ    RSS WCHAN  STAT   TT       TIME COMMAND
    501  1388   339   0  21 10  2433432    952 -      SN   s001    0:00.00 sh ./trap.sh
    
**`Tips : `** renice 命令自动更新运行进程的调度优先级。 与 `nice` 命令一样, `renice` 命令也有几个限制 :   

- 只能对拥有的进程使用 `renice` 命令
- 只能使用 `renice` 命令将进程调至更低的优先级。
- 根用户可以使用 `renice` 命令将任何进程调至任何优先级。


[返回目录](#toc)

#### 13.6 [准确无误地运行](id：准确无误地运行)

在开始处理脚本时, 总会遇到需要在给定时间运行脚本的情况。Linux 系统提供了 3 种方式在预定时间运行脚本 :  

- `at` 命令;
- `batch` 命令;
- `cron` 表格。

每种方法使用不同的技术调度运行脚本的时间和频率 :   

##### 13.6.1 [使用 at 命令调度作业](id:使用 at 命令调度作业)

`at` 命令允许指定 Linux 系统运行脚本的时间。 `at` 命令将作业提交到一个队列, 并指示 shell 在何时运行该作业。另一个命令 `atd` 以后台模式运行, 并检查作业队列以运行作业。大部分 Linux 发行版都可以在启动时自动启动该特性。

`atd` 命令检查系统上的特殊目录 (通常是 `/var/spool/at`), 以便运行使用 `at` 命令提交的作业。默认情况下, `atd` 命令每隔 60 秒检查一次该目录。如果存在作业, atd 命令检查运行作业的时间。如果时间与当前时间匹配, 则 `atd` 命令将运行该作业。

1. **at 命令格式**  
`at` 命令的基本格式很简单 :  

        at [-f filename] time
默认情况下, `at` 命令将 STDIN 的输入提交到队列。可以使用 `-f` 参数指定用于读取命令的文件名(脚本文件)。  
`time` 参数指定希望 Linux 系统运行作业的时间。指定时间的方式可以发挥创造性。 `at` 命令可以识别各种时间格式 :

    - 标准的小时和分钟格式, 比如 10:15;
    - AM/PM 指示符, 比如 10:15PM;
    - 具体指定的时间, 比如 now、noon、midnight、teatime(4PM)。     
    
    如果指定一个已经过去的时间, `at` 命令将在第二天的那个时间运行作业。    
    
    除了指定运行作业的时间之外, 还可以包括具体的日期, 可以使用各种日期格式 :   
    
    - 标准的日期格式, 比如 MMDDYY、MM/DD/YY 或者 DD.MM.YY
    - 文本日期格式, 比如 Jul 4 或 Dec 25, 有没有年份都可以 ;
    - 还可以指定时间增量 :   
        - Now +25 minutes
        - 10:15PM tomorrow
        - 10:15 +7 days
    
    使用 `at` 命令, 作业将提交到 **作业队列** (job queue) 中。作业队列保存 `at` 命令提交的作业以便处理。有 26 种不同的作业队列可用于不同优先级水平。使用小写字母 a 到 z 引用作业队列。
    
    默认情况下, 所有的 `at` 作业都提交到作业队列 a, 即最高的优先级队列。如果希望以较低的优先级运行作业, 则可以使用 `-q` 参数指定字母。
    
2. **获取作业输出**  

    作业在 Linux 系统运行时, 没有与该作业关联的监视器。Linux 使用提交作业的用户的电子邮件地址作为 STDOUT 和 STDERR。任何以 STDOUT 和 STDERR 为目的地的输出都将通过邮件系统发送给用户。
    
    以下是使用 `at` 命令调度作业运行的一个简单示例 :   
    
        #!/bin/bash
        
        time=`date +%T`
        echo "This script ran at $time"
        echo "This is the end of the script" >&2
        
        $ at -f testfile 12:07
        job 1 at Wed Aug 12 18:38:00 2015
    
    作业完成时, 监视器上不会显示任何内容, 但系统将生成一个电子邮件消息。电子邮件消息显示脚本生成的输出。如果脚本没有生成输出, 则默认情况下不会生成电子邮件消息。可以使用 `at` 命令的 `-m` 选项更改该特性。在脚本没有生成任何输出的情况下, 该选项可以生成一个电子邮件消息, 指示作业完成。
    
3. **列出排队的作业**   

    `atq` 命令能够查看系统中排队的作业 :   
    
        $ atq 
        1	Wed Aug 12 18:38:00 2015
        2	Wed Aug 12 19:10:00 2015
4. **移除作业**   

    了解了作业队列中排队作业的相关信息之后, 便可以使用 `atrm` 命令移除排队的作业 :   
        
        $ atrm 1 
        2	Wed Aug 12 19:10:00 2015
    只需要指定希望移除的作业编号即可。只能移除自己提交执行的作业。不能移除其他人提交的作业。


[返回目录](#toc)

##### 13.6.2 [使用 batch 命令](id:使用 batch 命令)

`batch` 命令与 `at` 命令稍有不同。 `batch` 命令的作用不是安排脚本在预设的时间运行, 而是安排脚本在系统使用率低时运行。

如果 Linux 系统正处于高负载水平, `batch` 命令将延迟提交作业的运行, 直到系统负载降低为止。这对于服务器是个很好的特性, 因为服务器在白天和夜晚的负载水平可能大不相同。您可以安排脚本在低负载水平时运行, 无需知道确切时间。

`batch` 命令检查 Linux 系统当前的平均负载水平。如果平均负载低于 0.8 , 它将运行任何在作业队列中等待的作业。

`batch` 命令的命令格式如下 :  
    
    batch [-f filename] [time]
与 `at` 命令类似, 默认情况下 `batch` 命令从 STDIN 读取命令。可以使用 `-f` 参数指定从读取命令的文件。还可以指定 `batch` 命令应该尝试运行作业的最早时间(可选)。


[返回目录](#toc)

##### 13.6.3 [调度定期脚本](id:调度定期脚本)

Linux 系统使用 `cron` 程序调度需定期运行的作业。`cron` 程序在后台运行, 它从特殊表格(cron 表格) 中查找需要调度运行的作业。

1. **cron 表格**   

    `cron` 表格敷衍特殊格式指定作业运行的时间。`cron` 表格的格式如下 : 
    
        min hour dayofmonth month dayofweek command
    `cron` 表格可以将条目指定为具体值、一定范围的值(如 1-5) 或通配符 (星号)。例如, 如果希望每天 10:15 运行命令, 可以使用以下 `cron` 表格项 :  
    
        15 10 * * * command
        
    要指定命令在每周一下午 4:15 运行, 可以使用 : 
        
        15 16 * * 1 command
    
    可以将 dayofweek 项指定为 3 字符串的文本值 (mon、tue、wed、thu、fri、sat、sun) 或数字值, 使用 0 表示星期天, 6 表示星期六。  
    
    dayofmonth 项指定每个月的日期值 ( 1 - 31)  
**`Tips : `** 如果在每月的最后一天执行命令的话, 可以用以下方法 :  

        00 12 * * * if [`date +%d -d tommorrow` = 01] ; then ; command
        
2. **构建 cron 表格**   

    每个系统用户都可以拥有自己的 `cron` 表格 (包括根用户) 以运行安排好的作业。 Linux 提供了 `crontab` 命令处理 `cron` 表格。要列出现有的 `cron` 表格, 可以使用 `-l` 参数 :   
    
        $ crontab -l
        no crontab for rich
    
    默认情况下, 每个用户的 `cron` 表格文件都不存在。要向 `cron` 表格添加条目, 可使用 `-e` 参数。这样做时, `crontab` 命令自动启动 vi 编辑器处理现有的 `cron` 表格 (如果没有, 则创建一个空文件)。
    
3. **anacron 程序**   

    使用 `cron` 程序存在的唯一一个问题是, 它假定 Linux 系统每天运行 24 个小时, 如果在某一时间关闭了, 错过了某些作业的执行, 那么我们是没办法处理的。
    
    `anacron` 程序使用时间戳确定调度的作业是否在正确的时间间隔运行。如果它确定某个作业错过了调度的运行时间, 它将自动尽快运行该作业。如果 Linux 系统关闭了好几天, 当它再次开启时, 任何计划在系统关闭期间运行的作业都将自动运行。
   
    该特性对于执行例行日志维护的脚本非常有用。如果系统在应该运行脚本时总是关机, 则日志文件半得不到清理, 文件大小可能会不断增大。使用 `anacron` 可以保证日志至少在每次系统启动时清理一次。
   
    `anacron` 程序使用自己的表格 (通常位于 `/etc/anacrontab`) 指定作业。该表格仅供根用户使用。 `anacron` 表格的格式 :  
       
        period delay identifier command

    `period` 项定义作业应该间隔多久运行一次, 以天为单位。`delay` 项指定在 `anacron` 程序确定应该运行一个命令之后需要多长时间才会实际运行该命令。该选项可以为不同的命令设置不同的延迟值, 以防止所有命令在一打开 Linux 系统时运行。   
    `identifier` 项是一个唯一的非空字符串, 可以唯一地标识日志消息和错误电子mbwrkh的作业。


[返回目录](#toc)

#### 13.7 [从头开始](id:从头开始)

下面讲如何配置 Linux 系统, 以在启动时或者每次启动新 bash shell 时运行脚本。

##### 13.7.1 [在启动时启动脚本](id:在启动时启动脚本)

Linux 在启动时按照一定的顺序启动脚本 :    

1. **启动过程**   

    在打开 Linux 系统之后, Linux 内核加载到内存并运行。最先运行的是 `int` 程序。因为 `int` 程序 ( 通常位于 `/sbin/init` )  总是第一个运行, 因此内核总是向它分配 PID 1。然后, `init` 进程负责启动 Linux 系统的所有其他进程。
    
    在启动过程中, `init` 程序读取 `/etc/inittab` 文件。`inittab` 文件列出了 `init` 程序以不同的 **运行级别** 启动的脚本。 Linux 运行级别定义 Linux 系统的操作状态。不同的运行级别启动不同的程序和脚本。  
    
    **Linux 运行级别**
    
    运行级别 | 描述
    ----|---
     0 | 停止
     1 | 单用户模式
     2 | 多用户模式, 通常没有网络支持
     3 | 完全多用户模式, 有网络
     4 | 未使用
     5 | 多用户模式, 有网络和图形 X Window 会话
     6 | 重启
    
    每个运行级别都定义 `init` 程序启动或终止的脚本。图形 Linux 系统的常见运行级别是 5。大部分 Linux 发行版以运行级别 3 启动所有服务器软件, 该级别允许多个用户登陆。
    
    Linux 系统通过 `rc` 脚本确定以哪种运行级别启动哪些程序。 `rc` 脚本确定当前系统的运行级别并在该运行级别上运行相应的脚本。
    
    Linux 系统使用 **启动脚本** (startup sctipt) 启动应用程序。启动脚本是启动应用程序的 shell 脚本, 为运行的程序提供必要的环境变量。
    
    Linux 启动过程的这部分使事情有些混乱, 主要是因为不同的 Linux 发行版放置启动脚本的位置稍有不同。有些放在 `/etc/rc.d` 目录, 有些放在 `/etc/init.d`, 而有些则放到 `/etc/init.d/rc.d` 目录。
    
2. **定义脚本**   

    最好不要弄乱 Linux 发行版中的任何启动脚本文件。发行版通常提供一此工具自动在添加服务器应用程序时构建这些脚本, 手动更改这些脚本可能会出现问题。
    
    大部分 Linux 发行版专门提供一个本地启动文件, 允许系统管理员输出在启动时运行的脚本。当然该文件的名称和位置随 Linux 发行版的不同而不同。
    
    **Linux 本地启动文件的位置**
    
    发行版 | 文件位置
    ----|---
    Debian | /etc/init.d/rc.local
    Fedora | /etc/rc.d/rc.local
    openSuse | /etc/init.d/boot.local
    
    在本地启动文件内部, 可以指定特定命令和语句, 或者输入希望在系统启动时启动的脚本。


[返回目录](#toc)

##### 13.7.2 [随新 shell 一起启动](id:随新 shell 一起启动)

每个用户的主目录都包含两个文件, bash shell 使用这两个文件自动启动脚本和设置环境变量 :  

- `.bash_profile` 文件;
- `.bashrc` 文件。

bash shell 在由于新用户登录而运行新的 shell 时运行 `.bash_profile` 文件。在该文件中放置任何您希望登录时运行的脚本。

bash shell 在每次启动新 shell 时 ( 包括新用户登录时 ) 运行 `.bashrc` 文件。可以向主目录的 `.bashrc` 文件添加一个简单的 echo 语句, 然后启动一个新 shell 以测试该特性 :   

    $ bash 
    This is a new shell !!
    
如果希望为系统的每个用户运行脚本, 可以使用大部分 Linux 发行版提供的 `/etc/bashrc` 文件。bash shell 在系统任何用户启动一个新 bash shell 时执行该文件中的语句。


[返回目录](#toc)





    













