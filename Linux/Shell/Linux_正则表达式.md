### Linux_正则表达式

### 17 [正则表达式](id:toc)

- 17.1 [正则表达式是什么](#正则表达式是什么)
    - 17.1.1 [正则表达式的定义](#正则表达式的定义)
    - 17.1.2 [正则表达式的类型](#正则表达式的类型)
    
- 17.2 [定义 BRE 模式](#定义 BRE 模式)
    - 17.2.1 [纯文本](#纯文本)
    - 17.2.2 [特殊字符](#特殊字符)
    - 17.2.3 [定位符](#定位符)
    - 17.2.4 [点字符](#点字符)
    - 17.2.5 [字符类](#字符类)
    - 17.2.6 [否定字符类](#否定字符类)
    - 17.2.7 [使用范围](#使用范围)
    - 17.2.8 [特殊字符类](#特殊字符类)
    - 17.2.9 [星号](#星号)

- 17.3 [扩展的正则表达式](#扩展的正则表达式)
    - 17.3.1 [问号](#问号)
    - 17.3.2 [加号](#加号)
    - 17.3.3 [使用大括号](#使用大括号)
    - 17.3.4 [管道符号](#管道符号)
    - 17.3.5 [将表达式分组](#将表达式分组)

- 17.4 [正则表达式实战](#正则表达式实战)
    - 17.4.1 [计算目录文件](#计算目录文件)
    - 17.4.2 [验证电话号码](#验证电话号码)
    - 17.4.3 [解析电子邮件地址](#解析电子邮件地址)
    
- [附录](#附录)

#### 17.1 [正则表达式是什么](id:正则表达式是什么)

##### 17.1.1 [正则表达式的定义](id:正则表达式的定义)

正则表达式是您定义的、Linux 实用程序用来筛选文本的模式模板。 Linux 实用程序 ( 如 sed 编辑器或 gawk 程序 ) 在输入数据时, 将正则表达式模式和数据进行匹配。如果数据与模式一致, 它接受处理。如果数据与模式不一致, 它就拒绝。

正则表达式模式利用通配符表示数据流中的一个或多个字符。在 Linux 中, 有许多场合可以指定通配符来表示您不了解的数据。

[返回目录](#toc)

##### 17.1.2 [正则表达式的类型](id:正则表达式的类型)

正则表达式可以使用 **正则表达式引擎** ( regular expression engine ) 实现。正则表达式引擎是解释正则表达式模式并使用这些模式匹配文本的基础软件。

在 Linux 世界, 常用的正则表达式引擎有两种 :  

- POSIX 基本正则表达式 ( BRE ) 引擎;
- POSIX 扩展正则表达式 ( ERE ) 引擎。

大多数 Linux 实用程序至少要符合 POSIX BRE 引擎规范, 能够识别其定义的所有模式符号。不过, 有些实用程序 ( 如 sed 编辑器 ) 只符合 BRE 引擎规范的一个子集。这主要是由于速度约束, 因为 sed 编辑器要尽可能快地处理数据流中的文本。gawk 程序使用 ERE 引擎处理正则表达式模式。

[返回目录](#toc)


#### 17.2 [定义 BRE 模式](id:定义 BRE 模式)

##### 17.2.1 [纯文本](id:纯文本)

    $ echo "This is a test" | sed -n '/test/p'
    This is a test
    $ echo "This is a test" | gawk '/test/{print $0}'
    This is a test

正则表达式第一条规则 : 区分大小写


    $ echo "This is a Test" | sed -n '/test/p'
    $            //无输出
    
正则表达式中可以匹配空格 :  

    $ echo "This is line number 1" | sed -n '/ber 1/p'
    This is line number 1

[返回目录](#toc)

##### 17.2.2 [特殊字符](id:特殊字符)

正则表达式特殊字符 :  

`.` `*` `[` `]` `^` `$` `{` `}` `\` `+` `?` `|` `(` `)`

如果要使用这些特殊字符中的一个作为文本字符, 需要 **转义** (escape) 它。转义特殊字符时, 需要在特殊字符的前面添加一个特殊字符, 向正则表达式引擎说明 :  它应该将下一个字符解释为普通文本字符。转义的方法是用反斜杠字符 ( \ ) 。

    $ cat data
    The cost is $4.00
    $ sed -n '/\$/p' data        //并未当作结尾符, 而是当作普通字符匹配
    The cost is $4.00

使用正斜杠, 也需要将它转义 :  

    $ echo "3 / 2" | sed -n '/\//p'
    3 / 2

[返回目录](#toc)

##### 17.2.3 [定位符](id:定位符)

有两个特殊字符可以用来将模式定位到数据流行的开头和行的结尾。

1. **从头开始**
    
    脱字符 ( ^ ) 定义从数据流中文本行开头开始的模式。如果该模式位于文本行的其他任意位置, 正则表达式失败。需要将脱字符放在正则表达式指定的模式之前 :  
    
        $ echo "The book store" | sed -n '/^book/p'
        $                                            //未匹配到，无输出
        $ ehco "Book are great" | sed -n '/^Book/p'
        Books are great
    
    如果, 脱字符定位符在其他位置, 它将充当普通字符而不再作为特殊字符 :  
    
        $ echo "This ^ is a test" | sed -n '/s ^/p'
        This ^ is a test
        
2. **查找结尾**

    美元符号 ( $ ) 特殊字符定义结尾定位。在文本模式之后添加这个特殊字符表示数据行必须以文本模式结束 :  


        $ echo "This is a good book" | sed -n '/book$/p'
        This is a good book
        $ echo "This book is good" | sed -n '/book$/p'
        $    //无匹配,无输出 
        
3. **联合定位**  

    如果两种情况同时存在, 可以将上面两个结合起来使用 :  
    
        $ sed -n '/^this is a test$/p' data
    
    也可以用 `^$` 来匹配空白行。

[返回目录](#toc)

##### 17.2.4 [点字符](id:点字符)

点特殊字符用于匹配除换行符之外的任何单个字符。但必须匹配且只能匹配一个字符。

    $ cat data
    This is a test of a line.
    This test is at line two.
    This cat is sleeping.
    
    $ sed -n '/.at/p' data
    This cat is sleeping.

[返回目录](#toc)

##### 17.2.5 [字符类](id:字符类)

如果要限制匹配的字符则要用表达式中称为 **字符类** ( character class )。为定义字符类, 要使用方括号。应该将要包括在该类中的所有字符用方括号括起来。然后在模式中使用整个字符类, 就像任意的其他通配符一样。

    $ sed -n '/[ch]at/p' data
    The cat is sleeping
    That is a very nice hat.
    
如果不确定某人字符的大小写, 字符类就可以派上用场 :  

    $ echo "Yes" | sed -n '/[Yy]es/p'
    Yes

[返回目录](#toc)

##### 17.2.6 [否定字符类](id:否定字符类)

**否定字符类** 查找不在该字符类中的字符, 只需在字符类范围的开头添加脱字符。

    $ cat data
    This is line number 2.       //含有 This
    his is line number 2.        //参看 Tips
    no his is line number 3.
    I know this is yours.        //含有 this
    
    $ sed -n '/[^Tt]his/p' data
    no his is line number 3.
    
**`Tips : `**  即使使用否定, 字符类仍必须`匹配一个字符`, 因此 his 位于该行最前面 ( 前面再无字符 ) 那一行仍与模式不匹配。

[返回目录](#toc)

##### 17.2.7 [使用范围](id:使用范围)

通过使用短划线符号可以在字符类中使用一系列字符范围。只需指定范围内的第一个字符、短划线, 砶是范围内的最后一个字符。根据 Linux 系统使用的字符集, 正则表达式包括指定字符范围内的所有字符。

> [0123456789] 可以简写成 [0-9]  
> [abc] 可以简写成 [a-c]  
> [abchijklm] 可简写成 [a-ch-m]   
> [0-9a-zA-Z] 是数字和字母大小写的集合

[返回目录](#toc)

##### 17.2.8 [特殊字符类](id:特殊字符类)

除定义自己的字符类之外, BRE 还包含特殊字符类, 可以用于匹配特定类型的字符。

**BRE 特殊字符类**

类 | 描述
----|---
`[[:alpha:]]` | 匹配任意字母字符, 大写或者小写
`[[:alnum:]]` | 匹配任意字母数字字符, 0~9、A~Z 或 a~z
`[[:blank:]]` | 匹配空格或者制表符字符
`[[:digit:]]` | 匹配 0~9 之间的数字
`[[:lower:]]` | 匹配任意小写字符, 即 a~z
`[[:print:]]` | 匹配任意可打印字符
`[[:punct:]]` | 匹配标点符号
`[[:space:]]` | 匹配任意空白字符 :  空格、制表符、NL、FF、VT、CR
`[[:upper:]]` | 匹配任意大写字母字符, 即 A~Z

    $ echo "abc" | sed -n '/[[:digit:]]/p'
    $    //无匹配, 无输出
    $ echo "abc" | sed -n '/[[:lower:]]/p'
    abc

[返回目录](#toc)

##### 17.2.9 [星号](id:星号)

在某个字符之后加一个星号表示该字符必须在匹配模式的文本中不出现或出现多次 ( 0 次到多次 ) : 

    $ echo "ik" | sed -n '/ie*k/p'
    ik
    $ echo "iek" | sed -n '/ie*k/p'
    iek
    $ echo "ieek" | sed -n '/ie*k/p'
    ieek
    
还可以将星号用于字符类 :  

    $ echo "bt" | sed -n '/b[ae]*t/p'
    bt
    $ echo "baaaaet" | sed -n '/b[ae]*t/p'
    baaaaet

[返回目录](#toc)

#### 17.3 [扩展的正则表达式](id:扩展的正则表达式)

POSIX ERE 模式包括某些 Linux 应用程序和工作使用的其他几个符号。gawk 程序能够识别 ERE 模式, 但 sed 编辑器不能, 虽然 gawk 比 sed 编辑器有更强的筛选能力, 但是, gawk 处理起来通常较慢。

##### 17.3.1 [问号](id:问号)

问号表示其前面的字符可以不出现或出现一次, 它不匹配重复出现的字符 :  

    $ echo "bt' | gawk '/be?t/{print $0}'
    bt
    $ echo "bet' | gawk '/be?t/{print $0}'
    bet
    $ echo "beet' | gawk '/be?t/{print $0}'
    $    

问号与可以和字符类连用 :  

    $ echo "bt" | gawk '/b[ae]?t/{print $0}'
    bt
    $ echo "bat" | gawk '/b[ae]?t/{print $0}'
    bat

[返回目录](#toc)

##### 17.3.2 [加号](id:加号)

加号表示其前面的字符可以出现一次或多次, 但必须出现至少一次。如果字符不存在, 则模式不匹配 :  

    $ echo "beeet" | gawk '/be+t/{print $0}'
    beeet
    $ echo "bet" | gawk '/be+t/{print $0}'
    bet
    $ echo "bt" | gawk '/be+t/{print $0}'
    $
    
加号和字符类连用 :  

    $ echo "bat" | gawk '/b[ae]+t/{print $0}'
    bat

[返回目录](#toc)

##### 17.3.3 [使用大括号](id:使用大括号)

在 ERE 中可以使用大括号指定对可重复的正则表达式的限制。这通常称为 **间隔** (interval) 。可以用两种格式表示间隔 :  


- `m` : 该正则表达式正好出现 m 次;
- `m,n` : 该正则表达式最少出现 m 次, 最多 n 次。

**`Tips : `** 默认情况下, gawk 程序不能识别正则表达式间隔。必须指定 `--re-interval` 命令选项, 以便 gawk 程序识别正则表达式间隔。

    $ echo "beet" | gawk --re-interval '/be{2}t/{print $0}'
    beet
    $ echo "bet" | gawk --re-interval '/be{2}t/{print $0}'
    $
    $ echo "bet" | gawk --re-interval '/be{1,2}t/{print $0}'
    bet
    $ echo "bat" | gawk --re-interval '/b[ae]{1,2}t/{print $0}'
    bat
    $ echo "beat" | gawk --re-interval '/b[ae]{1,2}t/{print $0}'
    beat

[返回目录](#toc)

##### 17.3.4 [管道符号](id:管道符号)

管道符号允许用逻辑 OR 公式指定正则表达式检查数据流时使用的两个或多个模式。如果任何一个模式与数据流匹配, 该文本通过。

使用管道符号的格式为 :  

    expr1|expr2|…

例子 :  

    $ echo "The cat is sleep" | gawk '/cat|dog/{print $0}'
    The cat is sleep
    $ echo "The dog is sleep" | gawk '/cat|dog/{print $0}'
    The dog is sleep
    
也可以与 字符类 连用 :  
    
    echo "He has a hat" | gawk '/[ch]at|dog/{print $0}'
    He has a hat

[返回目录](#toc)

该表达式实际上可以匹配的字符有 cat, hat, cdog, hdog。


##### 17.3.5 [将表达式分组](id:将表达式分组)

正则表达式模式也可以使用圆括号分组。在将正则表达式分组时, 一个组合将作为一个标准字符处理。

    $ echo "Sat" | gawk '/Sat(urday)?/{print $0}'
    Sat
    
    $ echo "bat" | gawk '/(c|b)a(b|t)/{print $0}'
    bat
    $ echo "bat" | gawk '/[cb]a[bt]/{print $0}'
    bat

[返回目录](#toc)

#### 17.4 [正则表达式实战](id:正则表达式实战)

##### 17.4.1 [计算目录文件](id:计算目录文件)

    $ echo $PATH | sed 's/:/ /g'
    /usr/bin /bin /usr/sbin /sbin /usr/local/bin
    
如果处理成上面的格式, 我们就可以将用 `for` 语句进行处理 : 

    mypath=`echo $PATH | sed 's/:/ /g'`
    for directory in $mypath
    do
    。。。
    done

代码如下 :  

    #!/bin/bash
    mypath=`echo $PATH | sed 's/:/ /g'`
    count=0
    
    for directory in $mypath
    do
        check=`ls $directory`
        for item in $check
        do
            count=$[ $count + 1 ]
        done
        echo "$directory - $count"
        count=0
    done

    $ ./testfile
    /usr/bin - 1090
    /bin - 37
    /usr/sbin - 267
    /sbin - 60
    /usr/local/bin - 66

[返回目录](#toc)

##### 17.4.2 [验证电话号码](id:验证电话号码)

通常电话号码显示格式有如下几种格式 :  

> (123) 456-7890  
> (123)  456-7890  
> 123-456-7890  
> 123.456.7890

下面我们从左边开始写 :  

首先, 电话号码可能有括号也可能没有括号, 但一定要在开头 : `^\(?`   
(`^` 表示数据开头, `\(` 表示将特殊字符转义为普通字符, `?` 表示左括号出现次数为 0 或 1)

然后, 接下来是三位数字的地区代码, 地区代码是以数字 2 开始 ( 没有 0 或 1 的地区代号 ) 最大可以到 9 : `[2-9][0-9]{2}`    
( `[2-9]` 第一位数字是从 2 到 9, `[0-9]{2}` 后两位是从 0 到 9 )

接下来, 右括号 :  `\)?`  
( 这个就是将 `\)` 转义为普通字符, 并且只能出现 0 次或 1 次 )

然后就是, 空格、没有空格、短划线或圆点 :  `(| |-|\.)`  
( `()` 将表达式打包, 其中的 `| |-|\.` 分别表示 `没有空格 | 有空格 | 有横线 | 有普通字符点号` )

其后, 三位数字交换号码 : `[0-9]{3}`

然后, 空格、破折号或者点字符 : `( |-|\.)`

最后, 4 位数字本地电话扩展码, 加结尾标记 : `[0-9]{4}$`

组合起来就是 : `^\(?[2-9][0-9]{2}\)?(| |-|\.)[0-9]{3}( |-|\.)[0-9]{4}$`

操作命令 : 

    $ echo "317-555-1234" | gawk --re-interval '/^\(?[2-9][0-9]{2}\)?(| |-|\.)[0-9]{3}( |-|\.)[0-9]{4}$/{print $0}'
    317-555-1234
    
    $ cat phonelist | gawk --re-interval '/^\(?[2-9][0-9]{2}\)?(| |-|\.)[0-9]{3}( |-|\.)[0-9]{4}$/{print $0}'

[返回目录](#toc)

##### 17.4.3 [解析电子邮件地址](id:解析电子邮件地址)

电子邮件的基本形式为 :  

    username@hostname
    
`username` 的值可以使用任意字母数字, 以及下面几个特殊字符 :  

- 圆点
- 短划线
- 加号
- 下划线

电子邮件地址的 `hostname` 部分由一个或多个域名和服务器名组成。服务器和域名也必须遵守严格的命令规则, 仅允许字母数字以及下面的特殊字符 :  

- 圆点
- 下划线

服务器和域名之间分别用圆点隔开, 且先指定服务器名, 然后指定子域名, 最后是没有后缀圆点的顶级域名。

用户名中有多少合法字符。这个非常简单 :  `^([a-zA-Z0-9_\-\.\+]+)@`

这样组合可以指定用户名中允许的字符, 加号表示要存在至少一个字符。下个字符显示应该是 `@` 。

主机名模式使用相同的方法匹配服务器名和子域名 :  `([a-zA-Z0-9_\-\.]+)`

顶级域名有特殊的规则。顶级域名只能是字母字符, 并且不能少于两个字符 ( 在国家码部分使用 ) 且长度不能超过 5 个字符。用于顶级域名的正则表达式为 :  `\.([a-zA-Z]{2,5})$`

组合起来得到 :  `^([a-zA-Z0-9_\-\.\+]+)@([a-zA-Z0-9_\-\.]+)\.([a-zA-Z]{2,5})$`

可以筛选不符合要求的电子地址 :  

    $ cat ./isemail
    #!/bin/bash
    gawk --re-interval '/^\(?[2-9][0-9]{2}\)?(| |-|\.)[0-9]{3}( |-|\.)[0-9]{4}$/{print $0}'
    
    $ echo "rich@here.now" | ./isemail
    rich@here.now

[返回目录](#toc)








#### [附录](id:附录)

正则表达式特殊字符 :  

`.` `*` `[` `]` `^` `$` `{` `}` `\` `+` `?` `|` `(` `)`

**特殊字符用途**

字符 | 描述
----|---
`^` | 匹配开始
`$` | 匹配结尾
`.` | 匹配除换行符之外的任何单个字符。(不得为空)
`[]` | 字符类, 限制匹配的字符, 必须匹配方括号中的一个字符
`[^]` | 否定字符类, 限制匹配的字符, 必须匹配不包含在方括号号中的一个字符
`?` | 匹配 0次 或 1次 指定字符
`+` | 匹配至少 1次 指定字符
`{}` | 间隔, 对可重复的正则表达式的匹配次数的限制
`\|` | 管道符号, 正则表达式中的逻辑 OR 
`()` | 分组表达式, 一个组合将作为一个标准字符处理。

-----
**BRE 特殊字符类**

类 | 描述
----|---
`[[:alpha:]]` | 匹配任意字母字符, 大写或者小写
`[[:alnum:]]` | 匹配任意字母数字字符, 0~9、A~Z 或 a~z
`[[:blank:]]` | 匹配空格或者制表符字符
`[[:digit:]]` | 匹配 0~9 之间的数字
`[[:lower:]]` | 匹配任意小写字符, 即 a~z
`[[:print:]]` | 匹配任意可打印字符
`[[:punct:]]` | 匹配标点符号
`[[:space:]]` | 匹配任意空白字符 :  空格、制表符、NL、FF、VT、CR
`[[:upper:]]` | 匹配任意大写字母字符, 即 A~Z

-----

正则表达式规则 :  

1. 区分大小写

[返回目录](#toc)


