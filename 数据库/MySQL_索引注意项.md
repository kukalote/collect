# MySQL_索引注意项

<!-- create time: 2016-03-28 10:26:15  -->

<!-- This file is created from $MARBOO_HOME/.media/starts/default.md
本文件由 $MARBOO_HOME/.media/starts/default.md 复制而来 -->

索引在检索大数据时会大大提高查询查询速度, 同时会降低更新速度, 如对表进行 INSERT、UPDATE和DELETE。

记录索引会占用磁盘空间的索引空间。一般情况这个问题不会太严重, 但如果在一个大表创建了多种组合索引, 索引文件的膨胀会很快。



使用索引就需要一些技巧和注意事项 : 

**1. 索引不会包含有 NULL 值的列**

只要列中有 NULL 值都将不会被包含在 MySQL 索引中, 复合索引中只要有一列含有 NULL 值, 那么这一列对此复合索引就是无效的。所以设计数据库时字段不要默认为 NULL。

**2. 使用短索引**

如果索引列长度过长, 可以指定一个前缀为索引。如 varchar(255) 的列, 如果在前10 或20 个字符肉, 多数值是惟一的, 那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和 I/O 操作。

**3. 索引列排序**

MySQL 查询只使用一个索引, 因此如果 where 子句中已使用了索引的话, 那么 order by 中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作; 尽量不要包含多个列的排序, 如果需要最好给这些列创建复合索引。

**4. like 语句操作**

一般情况下不鼓励使用 like 操作, 如果非使用不可, 如果使用也是一个问题。 `like "%aaa%"` 不会使用索引 MySQL 索引而 `like "aaa%"` 可以使用索引。

**5. 不要在列上进行运算**

`select * from users where YEAR(adddate) < 2007;` 将在每个行上进行运算, 这将导致索引失效而进行全表扫描, 因此我们可以改成 `select * from users where adddate<‘2007-01-01';` 

也不使用 `NOT IN` 和 `<>` 操作。

#### 限制

1. 从理论上讲，完全可以为数据表里的每个字段分别建一个索引，但MySQL把同一个数据表里的索引总数限制为`16`个。

2. 如果`WHERE`子句的查询条件里有不等号`(WHERE coloum != ...)`，MySQL将无法使用索引。  
> 类似地，如果WHERE子句的查询条件里使用了函数`(WHERE DAY(column) = ...)`，MySQL也将无法使用索引。    
> 在`JOIN`操作中(需要从多个数据表提取数据时)，MySQL只有在主键和外键的数据类型相同时才能使用索引。   
> 如果`WHERE`子句的查询条件里使用比较操作符`LIKE`和`REGEXP`，MySQL只有在搜索模板的第一个字符不是通配符的情况下才能使用索引。  
> 比如说，如果查询条件是`LIKE 'abc%'`，MySQL将使用索引；如果查询条件是`LIKE '%abc'`，MySQL将不使用索引。  
　　
3. 在`ORDER BY`操作中，MySQL只有在排序条件不是一个查询条件表达式的情况下才使用索引。
> (虽然如此，在涉及多个数据表查询里，即使有索引可用，那些索引在加快ORDER BY方面也没什么作用)

4. 如果某个数据列里包含许多重复的值，就算为它建立了索引也不会有很好的效果。  
   比如说，如果某个数据列里包含的净是些诸如"0/1"或"Y/N"等值，就没有必要为它创建一个索引。 
   

### InnoDB数据表的索引

与MyISAM数据表相比，索引对InnoDB数据的重要性要大得多。

在InnoDB数据表上，索引不仅会在搜索数据记录时发挥作用，还是数据行级锁定机制的苊、基础。"数据行级锁定"的意思是指在事务操作的执行过程中锁定正在被处理的个别记录，不让其他用户进行访问。  
这种锁定将影响到(但不限于) `SELECT...LOCK IN SHARE MODE` 、 `SELECT...FOR UPDATE` 命令以及 `INSERT` 、 `UPDATE` 和 `DELETE` 命令。  

出于效率方面的考虑，InnoDB数据表的数据行级锁定实际发生在它们的索引上，而不是数据表自身上。显然，数据行级锁定机制只有在有关的数据表有一个合适的索引可供锁定的时候才能发挥效力。 