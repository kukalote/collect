### vim_代码折叠介绍

#### 手动折叠

所有折叠命令都以 `z` 开头。
    
    zf    Fold create (创建折叠)
    zo    Open a fold (打开折叠)
    zc    Close a fold (关闭折叠)

>**嵌套折叠**

>一个含有折叠的文本区可以被再次折叠。

    zr    减少折叠(Reduce)
    zm    折叠更多(More)
    zR    打开嵌套折叠
    zM    关闭嵌套折叠
    zn    快速禁止折叠功能
    zN    恢复原来的折叠
    zi    切换于两者间
    
>**zi实际操作**

> - 创建折叠, 以获取你的文件的概览
> - 移动到你要操作的地方
> - 执行`|zi|` 以便一边看着文本一边编辑
> - 再执行 `|zi|` 以便移动到另一处

**折叠的其他操作**

    zO    打开所有光标行上的折叠
    zC    关闭所有光标行上的折叠
    zd    删除一个光标行上的折叠
    zD    删除所有光标行上的折叠

> - 创建折叠 : 默认文本中是没有折叠的，需要创建
> - 关闭折叠 : 将折叠中的文本收起
> - 打开折叠 : 将折叠中的文本展开
> - 删除折叠 : 将创建的折叠删除，文本将不能被折叠收起

----

#### 对折叠的操作

1. 移动与转移

    你可以使用移动命令移过折叠行, 就像它是单个空行一样。
    
    也可以像对单行一样进行复制、删除和粘贴折叠行。
    
2. 查看折叠

    查看和记住一个折叠位置并不容易, 我们可以设置一个选项:
    
        :set foldcolumn=4
    
    >这个命令将在窗口左边显示一个小栏来标识各个折叠。
    
    > - `+` 表示某个关闭的折叠。
    > - `-` 表示每个打开的折叠开头。
    > - `|` 表示折叠内其余的行。 

    其他打开折叠的方法 : 
    
    1. 进入插入模式后, 光标行上的折叠不会关闭。
    2. 光标跳转到折叠, 或在折叠上左右移动时, 折叠会自动打开。(如查找、定位-0)。
    3. `foldopen` 选项 : 光标移动到关闭折叠, 对指定命令类型会打开折叠。    
    > `foldopen` 选项介绍 :   
    >
    > 项目 | 命令
    --|--
    all| 任何
    block | `"("、"{"、"[["、"[{" 等`
    hor | `水平移动 : "l"、"w"、"fx"`
    insert | `任何插入模式下的命令`
    jump | `远距离跳转 : "G"、"gg" 等`
    mark | `跳转到位置标记:"'m"、Ctrl-O 等`
    percent | `"%"`
    quickfix | `":cn"、":crew"、":make" 等`
    search | `搜索模式: "/"、"n"、"*"、 "gd" 等  (不适用于 ":" 命令里的模式搜索)  也用于 "[s" 和 "]s"` 
    tag | `跳转标签: ":ta"、 Ctrl-T 等`
    undo | `撤销或重做: "u" 和 Ctrl-R 等`
    
    可以在移开折叠时自动关闭折叠 `:set foldclose=all`, 这个命令将重新把折叠级别 `foldlevel` 作用到所有的不含光标的折叠。可以用 `zm` 和 `zr` 来调整折叠级别。
    
    折叠是限于本窗口的。使用 vim 分屏可以看出区别。


---

#### 存储和恢复折叠

当你放弃一个文件时(开始编辑另一个), 其折叠状态就丢失了。如果你稍后再回来编辑同一个文件, 那么, 所有手动打开和关闭的折叠都消失了!为了保存折叠, 可以用 `:mkview` 命令 : 

    :mkview
    
这将储存那些影响文件视图的设定及其它内容。你可以利用 `viewoptions` 选项修改储存的范围。当脸稍后回到同一文件时, 你可以重新载入这个视图 : 

    :loadview
    
你可以为一个文件储存十个视图。你可以将当前视图储存为第三个视图, 并载入第二个视图 : 

    :mkview 3
    :loadview 2
    
> 当你插入或者删除一些文本行时, 视图可能变得无效。还得检查 `viewdir` 选项, 它指定视图文件储存在哪。你可能需要删除旧的视图文件。、

----

#### 依缩进折叠

缩进较多的行将成为嵌套的折叠。可以设定 : 

    :set foldmethod=indent
    
然后可以用 `zm` 和 `zr` 命令增加和减少折叠。

> 缩进多少和折叠深度之间的关系倚赖于 `shiftwidth` 选项。每个 `shiftwidth` 选项规定的缩进宽度, 在折叠深度加一。这被称为一个折叠级别。

当使用 `zr` 和 `zm` 命令时, 实际上是在增加或减少 `foldlevel` 选项。也可以直接设置它 : 

    :set foldlevel=3
    
这意味着, 所有缩进等于或大于 `shiftwidth` 三倍的折叠将被关闭。折叠级别设定得越低, 越多的折叠将被关闭。当 `foldlevel` 为零时, 所有的折叠都将被关闭。 `zM` 把 `foldlevel` 设为零。相反的命令 `zR` 把 `foldlevel` 设为文件中最深的折叠级别。

**有两种方法开启和关闭折叠**

1. 设定折叠级别

    这提供了一种极快的 "缩小" 方法来查看文本结构, 移动光标, 以及重新 "放大" 到具体的文本。
    
2. 利用 `zo` 和 `zc` 命令打开和关闭指定的折叠。

    这个方法允许你仅仅打开那些你要打开的折叠, 而不影响其它的折叠。
    
> 当折叠方法为 `foldmethod` 的值为 “indent” 时, 你不能手动定义折叠。

----

#### 依标志折叠

文本中的标志用于指定一个折叠的起点和终点。标志折叠可以精确控制一个折叠究竟包含哪些行文本。缺点是文本需要改动。

    :set foldmethod=marker
    
    /* global variables {{{1 */
    int var A,var B;
    /* functions {{{1 */
    /* funcA() {{{2 */     void funcA() {}
    /* funcB() {{{2 */ 
    void funcB() {}    /* }}}1 */

每一个编号标志表示一个编号指定级别的折叠的开始。这将使任何较高层次的折叠在此结束。你可以只用编号标志的开始符定义所有的折叠。只有当你要明确地在另一个开始前结束一个折叠时, 你才需要加一个标志停止符。

---

#### 折叠代码配置

1. **foldmethod**

    设置选项 `foldmethod` 为非 `“manual”` 的其他值时, 所有的折叠都会被删除并且创新的。如果设置成 `"manual"`, 将不去除已有的折叠。可以利用这一点来先自动定义折叠, 然后手工调整。
    
    有 6 种方式来选定折叠 : 
    
        manual    手工定义折叠
        indent    更多的缩进表示更高级别的折叠
        expr      用表达式定义折叠
        syntax    用语法高亮来定义折叠
        diff      对没有更改的文本进行折叠
        marker    对文中的标志折叠
        
    **手工**
    
    
    使用命令来手工定义折叠的范围。分析文本并发现折叠的脚本也可以使用这种方法。
    
    折叠的级别公由嵌套次数来定义。要对一定行数的折叠增加级别, 可以对相同的行反复定义折叠。
    
    当你退出文件编辑时, 手工折叠会被遗弃。要保存折叠, 使用 `|:mkview|` 命令。之后要恢复可以使用 `|:loadview|`。
    
    **缩进**
    
    由缩进行自动定义折叠。
    
    折叠级别由行的缩进除以 `shiftwidth` (向下取整) 计算而得。连续的, 有同样或更高的折叠级别的行, 形成一个折叠。在其中, 有更高折叠级别的行形成嵌套的折叠。
    
    嵌套的级别受 `foldnestmax` 选项限制。
    
    某些行会被忽略并得到上一行或下一行的折叠级别 (取较小值)。 符合条件的这样的行要么是空行, 要么以 `foldignore` 选项里面包含的字符开始。在查找 `foldignore` 里面包含的字符时, 空白符会被忽略。对于 C, 该选项使用 `#` 来略过要预处理的那些行。
    
    当你想用另一种方式来略过行时, 使用 `expr` 方法。在 `foldexpr` 中 `|indent()|` 函数被用来取得一行的缩进。
    
    **表达式**
    
    就像用 `indent` 方式一样, 表达式方法的折叠也是由折叠级别自定义的。对于每行, 通过计算选项 `foldexpr` 的值来并得到它的折叠级别。如 : 
    
        对所有以制表符开始的连续的几行, 创建折叠 : 
        :set foldexpr=getline(v:lnum)[0]==\"\\t\"
        调用一函数来计算折叠级别 : 
        :set foldexpr=MyFoldLevel(v:lnum)
        用空白行分开的段落构成折叠 : 
        :set foldexpr=getline(v:lnum)=~'^\\s*$'&&getline(v:lnum+1)=~'\\S'?'<1':1
        同上 : 
        :set foldexpr=getline(v:lnum-1)=~'^\\s*$\&&getline(v:lnum)=~'\\S'?'>1':1
        
    注 : `set` 要特殊处理的字符必须用反斜杠转义。
    
    > 这些是表达式的计算条件 :  
    > 
    > - 当前缓冲区和窗口值依所在行而定
    > - 变量 "v:lnum" 被定为该行行号
    > - 计算结果将用以下方式解释 : 
        
    >   值 | 代表 
        ---|--
        0 | 这行不折叠
        1, 2, .. | 这行的折叠级别1, 2等
        -1 | 折叠级别没有定义, 使用这行之前或之后一行的级别值, 取其中较小的一个
        "=" | 使用上一行的折叠级别
        "a1", "a2", … | 上一行的折叠级别加1, 2, …
        "s1", "s2", … | 上一行的折叠级别减1, 2, …
        "<1", "<2", … | 此折叠级别在本行结束
        ">1", ">2", … | 此折叠级别在本行开始
    >
    > `不需要用 ">1" ("<1") 标志折叠的开始(结束)`。 当这行折叠级别高于 (低于) 上一行的级别时, 折叠将开始(结束)。  
    > 
    > `表达式必须没有副作用`。在缓冲区里的文字, 光标位置, 查找模式, 选项等等, 不能被改动。如果你非常小心, 改动并恢复这些设置还是可以的。
    >
    > `表达式中有错误或者计算结果不能识别时, Vim 不会产生错误消息, 而是将折叠级别设为0`。所以当需要调试时, 可将 `debug` 选项设为 `msg`, 错误消息就可以被见到了。
    
    **备注** 
    
    1. 由于每一行关于表达式的值都要被计算, 这一折叠方式可能会很慢!
    
    2. 最好避免使用 "=", "a" 和 "s" 作为返回值, 因为 Vim 不得不经常向回溯得到折叠级别。这会降低执行速度。
    
    3. `foldlevel()` 计算相对于上一折叠级别的折叠级别。但要注意, 如果该级别未知, `foldlevel()` 返回 -1。 它返回的级别对应于开始的位置, 尽管折叠本身可能在该行结束。
    
    4. 折叠可能会没有及时更新。用 `zx` 或者 `zX` 可以强制折叠更新。