# HTTP-缓存
web缓存是可以自动保存常见文档的HTTP设备，当web请求抵达缓存时，如果本地有已经缓存的副本，就可以从本地存储设备中提取这文档。

**缓存优点**：

- 缓存减少了冗余的数据传输，节省了网络带宽
- 缓存缓解了网络瓶颈的问题，不需要更多的带宽就能够更快的加载页面
- 缓存降低了对原始服务器的压力，避免过载出现
- 缓存降低了距离时延，因为从较远的地方加载页面会更慢一点

### 当前网络主要问题

**冗余的数据传输**

**带宽瓶颈**
> 网络总会以路径中最慢的访问服务器。

**瞬间拥塞**
> 服务器端软硬的并发处理能力，会影响网络延迟

**距离时延**
> - 网络交换和路由，会存在延迟
- 远程主机，造成延时
- 不同的网络协议，不同运营商
- 纯粹的物理层面的影响，也不能忽略

![](./image/http_cache_1.png) 

### 缓存步骤
Web缓存的基本工作原理大多很简单。对一条HTTP GET报文的基本缓存处理过程包括7个步骤：
1. 接收——缓存从网络中读取抵达的请求报文
2. 解析——缓存对报文进行解析，提取URL和各种首部
3. 查询——缓存查看是否有本地副本可用，如果没有，就获取一份副本(将其保存在**本地**)
4. 新鲜度检测——**缓存**查看已缓存的副本是否足够新鲜，如果不是，就询问**服务器**是否有任何更新
5. 创建响应——**缓存**会用新的首部和已缓存的主体来构建一条响应报文
6. 发送——**缓存**通过网络将响应发回给客户端
7. 日志——**缓存**可选的创建一个日志文件条目来描述这个事务
![](./image/http_cache_2.png) 

### 命中与再验证

**缓存命中**
可以用已有的副本为某些到达缓存的请求提供服务，这被称为缓存命中（cache hit），其他一些到达缓存的请求可能会由于没有副本可用，而被转发给原始服务器，这些被称为缓存未命中（cache miss）

**再验证**
原始服务器的内容可能会发生变化，缓存要不时的对其进行检测，看看它们保存的副本是否仍然是服务器上最新的副本，这些“新鲜度检测”被称为HTTP再验证(revalidation)。为了有效的进行再验证，HTTP定义了一些特殊的请求，不用从服务器上获取整个对象，就可以快速检测出内容是否是最新的。
![](./image/http_cache_3.png) 

缓存对缓存的副本进行再验证时，会向原始服务器发送一个小的再验证请求，如果内容没有变化，服务器会以一个小的304 Not Modified进行响应，只要缓存知道副本仍然有效，就会再次将副本标识为暂时新鲜的，并将副本提供给客户端，这被称为再验证命中或缓慢命中。

>**再验证未命中**
如果服务器对象与缓存的不同,会向客户端发送一个HTTP 200 ok的响应码
**对象被删除**
如果服务器对象被删除,会向客户端发送一个HTTP404的响应码,并删除起缓存副本



#### 保持副本新鲜

通过**cache-control **和 **expires** 2个首部可以说明多长时间内可以将该文档视为新鲜的。

- **cache-control:max-age=2592000** 表示该副本可以缓存2592000s时间
- **expires：Thu,12 Dec 2013 12:17:03**  表示该副本可以使用到2013-12-12号的12点17分03秒。

由于**cache-control**使用的是相对时间而不是**expires**的绝对时间，又由于可能用户客户端和服务器不在一个时区中的问题，所以应该更加的倾向于使用cache-control来判断副本是否过期。

#### 用条件方法进行验证

 HTTP的条件方法可以高效的实现再验证。HTTP允许缓存向原始服务器发送一个“条件GET”，请求服务器只有在文档与缓存中现有的副本不同时，才回送对象主体。通过这种方式，将新鲜度检测和对象获取结合成单个条件GET。只有条件为真时，web服务器才会返回对象。
HTTP定义了5个条件请求首部。对于缓存再验证来说最有用的2个首部是**If-Modified-Since**和**If-None-Match**。所有的条件首部都以**If**-作为开头。

首部 | 描述
----|---
`If-Modified-Since:<date>` |  如果指定日期之后文档被修改过，就执行请求的方法。可以与**Last-Modified**服务器响应首部配合使用。
`If-None-Match:<tags>` | 服务器可以为文档提供特殊标签`<ETag>`，而不是将其与最新的修改日期匹配，这些标签就像序列号一样。如果已缓存标签与服务器文件中的标签有所不同，**If-None-Match**首部就会执行所请求的方法。

如果服务器回送了一个实体标签，HTTP/1.1客户端就必须使用实体标签验证，如果服务器只回送了一个**Last-Modified**值，客户端就可以使用**If-Modified-Since**验证。如果两者都提供，客户端就应该使用这两种再验证方案，这样HTTP/1.0 ,HTTP/1.1缓存就都可以正确响应了。
![](./image/http_cache_4.png) 
![](./image/http_cache_5.png) 

#### 控制缓存的能力
服务器可以通过定义几种方式来指定文档过期之前可以将其缓存多长时间，按照优先级递减的顺序

> 1. cache-control：no-store
2. cache-control：no-cache
3. must-revalidate
4. cache-control：max-age
5. expires

**no-store**

	响应会禁止缓存对响应进行复制，缓存通常会像非缓存代理服务器一样，向客户端转发一条**no-store**响应，然后删除对象。
	
**no-cache**

	响应实际上是可以存储在本地的，只是在与服务器进行新鲜度再验证之前，缓存不能将其提供给客户端使用。
	
**max-age**

	**cache-control：max-age**首部表示从服务器将文档传来之时起，可以认为此文档处于新鲜度状态的秒数。还有一个**s-maxage**首部，与它类似，但仅适用于共享缓存
	
**expires**

	表示副本过期日期，不推荐适用
	
**must-revalidate**

	顾名思义，再事先没有跟原始服务器进行再验证的情况下，不能提供这个对象的陈旧副本，缓存仍然可以随意提供新鲜的副本。如果再缓存进行must-revalidate检查时，原始服务器不可用，那么缓存就会返回一条504Gateway Timeout错误
~~~~~~~~
